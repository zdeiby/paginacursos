{"ast":null,"code":"'use strict';\n\nconst stream = require('stream');\nconst Transform = stream.Transform;\n\n/**\n * Escapes dots in the beginning of lines. Ends the stream with <CR><LF>.<CR><LF>\n * Also makes sure that only <CR><LF> sequences are used for linebreaks\n *\n * @param {Object} options Stream options\n */\nclass DataStream extends Transform {\n  constructor(options) {\n    super(options);\n    // init Transform\n    this.options = options || {};\n    this._curLine = '';\n    this.inByteCount = 0;\n    this.outByteCount = 0;\n    this.lastByte = false;\n  }\n\n  /**\n   * Escapes dots\n   */\n  _transform(chunk, encoding, done) {\n    let chunks = [];\n    let chunklen = 0;\n    let i,\n      len,\n      lastPos = 0;\n    let buf;\n    if (!chunk || !chunk.length) {\n      return done();\n    }\n    if (typeof chunk === 'string') {\n      chunk = Buffer.from(chunk);\n    }\n    this.inByteCount += chunk.length;\n    for (i = 0, len = chunk.length; i < len; i++) {\n      if (chunk[i] === 0x2e) {\n        // .\n        if (i && chunk[i - 1] === 0x0a || !i && (!this.lastByte || this.lastByte === 0x0a)) {\n          buf = chunk.slice(lastPos, i + 1);\n          chunks.push(buf);\n          chunks.push(Buffer.from('.'));\n          chunklen += buf.length + 1;\n          lastPos = i + 1;\n        }\n      } else if (chunk[i] === 0x0a) {\n        // .\n        if (i && chunk[i - 1] !== 0x0d || !i && this.lastByte !== 0x0d) {\n          if (i > lastPos) {\n            buf = chunk.slice(lastPos, i);\n            chunks.push(buf);\n            chunklen += buf.length + 2;\n          } else {\n            chunklen += 2;\n          }\n          chunks.push(Buffer.from('\\r\\n'));\n          lastPos = i + 1;\n        }\n      }\n    }\n    if (chunklen) {\n      // add last piece\n      if (lastPos < chunk.length) {\n        buf = chunk.slice(lastPos);\n        chunks.push(buf);\n        chunklen += buf.length;\n      }\n      this.outByteCount += chunklen;\n      this.push(Buffer.concat(chunks, chunklen));\n    } else {\n      this.outByteCount += chunk.length;\n      this.push(chunk);\n    }\n    this.lastByte = chunk[chunk.length - 1];\n    done();\n  }\n\n  /**\n   * Finalizes the stream with a dot on a single line\n   */\n  _flush(done) {\n    let buf;\n    if (this.lastByte === 0x0a) {\n      buf = Buffer.from('.\\r\\n');\n    } else if (this.lastByte === 0x0d) {\n      buf = Buffer.from('\\n.\\r\\n');\n    } else {\n      buf = Buffer.from('\\r\\n.\\r\\n');\n    }\n    this.outByteCount += buf.length;\n    this.push(buf);\n    done();\n  }\n}\nmodule.exports = DataStream;","map":{"version":3,"names":["stream","require","Transform","DataStream","constructor","options","_curLine","inByteCount","outByteCount","lastByte","_transform","chunk","encoding","done","chunks","chunklen","i","len","lastPos","buf","length","Buffer","from","slice","push","concat","_flush","module","exports"],"sources":["C:/Users/deiby/Desktop/cloneWebCursos/paginacursos/node_modules/nodemailer/lib/smtp-connection/data-stream.js"],"sourcesContent":["'use strict';\n\nconst stream = require('stream');\nconst Transform = stream.Transform;\n\n/**\n * Escapes dots in the beginning of lines. Ends the stream with <CR><LF>.<CR><LF>\n * Also makes sure that only <CR><LF> sequences are used for linebreaks\n *\n * @param {Object} options Stream options\n */\nclass DataStream extends Transform {\n    constructor(options) {\n        super(options);\n        // init Transform\n        this.options = options || {};\n        this._curLine = '';\n\n        this.inByteCount = 0;\n        this.outByteCount = 0;\n        this.lastByte = false;\n    }\n\n    /**\n     * Escapes dots\n     */\n    _transform(chunk, encoding, done) {\n        let chunks = [];\n        let chunklen = 0;\n        let i,\n            len,\n            lastPos = 0;\n        let buf;\n\n        if (!chunk || !chunk.length) {\n            return done();\n        }\n\n        if (typeof chunk === 'string') {\n            chunk = Buffer.from(chunk);\n        }\n\n        this.inByteCount += chunk.length;\n\n        for (i = 0, len = chunk.length; i < len; i++) {\n            if (chunk[i] === 0x2e) {\n                // .\n                if ((i && chunk[i - 1] === 0x0a) || (!i && (!this.lastByte || this.lastByte === 0x0a))) {\n                    buf = chunk.slice(lastPos, i + 1);\n                    chunks.push(buf);\n                    chunks.push(Buffer.from('.'));\n                    chunklen += buf.length + 1;\n                    lastPos = i + 1;\n                }\n            } else if (chunk[i] === 0x0a) {\n                // .\n                if ((i && chunk[i - 1] !== 0x0d) || (!i && this.lastByte !== 0x0d)) {\n                    if (i > lastPos) {\n                        buf = chunk.slice(lastPos, i);\n                        chunks.push(buf);\n                        chunklen += buf.length + 2;\n                    } else {\n                        chunklen += 2;\n                    }\n                    chunks.push(Buffer.from('\\r\\n'));\n                    lastPos = i + 1;\n                }\n            }\n        }\n\n        if (chunklen) {\n            // add last piece\n            if (lastPos < chunk.length) {\n                buf = chunk.slice(lastPos);\n                chunks.push(buf);\n                chunklen += buf.length;\n            }\n\n            this.outByteCount += chunklen;\n            this.push(Buffer.concat(chunks, chunklen));\n        } else {\n            this.outByteCount += chunk.length;\n            this.push(chunk);\n        }\n\n        this.lastByte = chunk[chunk.length - 1];\n        done();\n    }\n\n    /**\n     * Finalizes the stream with a dot on a single line\n     */\n    _flush(done) {\n        let buf;\n        if (this.lastByte === 0x0a) {\n            buf = Buffer.from('.\\r\\n');\n        } else if (this.lastByte === 0x0d) {\n            buf = Buffer.from('\\n.\\r\\n');\n        } else {\n            buf = Buffer.from('\\r\\n.\\r\\n');\n        }\n        this.outByteCount += buf.length;\n        this.push(buf);\n        done();\n    }\n}\n\nmodule.exports = DataStream;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}