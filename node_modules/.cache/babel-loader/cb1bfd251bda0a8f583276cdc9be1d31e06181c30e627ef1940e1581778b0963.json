{"ast":null,"code":"'use strict';\n\nconst http = require('http');\nconst https = require('https');\nconst urllib = require('url');\nconst zlib = require('zlib');\nconst PassThrough = require('stream').PassThrough;\nconst Cookies = require('./cookies');\nconst packageData = require('../../package.json');\nconst net = require('net');\nconst MAX_REDIRECTS = 5;\nmodule.exports = function (url, options) {\n  return nmfetch(url, options);\n};\nmodule.exports.Cookies = Cookies;\nfunction nmfetch(url, options) {\n  options = options || {};\n  options.fetchRes = options.fetchRes || new PassThrough();\n  options.cookies = options.cookies || new Cookies();\n  options.redirects = options.redirects || 0;\n  options.maxRedirects = isNaN(options.maxRedirects) ? MAX_REDIRECTS : options.maxRedirects;\n  if (options.cookie) {\n    [].concat(options.cookie || []).forEach(cookie => {\n      options.cookies.set(cookie, url);\n    });\n    options.cookie = false;\n  }\n  let fetchRes = options.fetchRes;\n  let parsed = urllib.parse(url);\n  let method = (options.method || '').toString().trim().toUpperCase() || 'GET';\n  let finished = false;\n  let cookies;\n  let body;\n  let handler = parsed.protocol === 'https:' ? https : http;\n  let headers = {\n    'accept-encoding': 'gzip,deflate',\n    'user-agent': 'nodemailer/' + packageData.version\n  };\n  Object.keys(options.headers || {}).forEach(key => {\n    headers[key.toLowerCase().trim()] = options.headers[key];\n  });\n  if (options.userAgent) {\n    headers['user-agent'] = options.userAgent;\n  }\n  if (parsed.auth) {\n    headers.Authorization = 'Basic ' + Buffer.from(parsed.auth).toString('base64');\n  }\n  if (cookies = options.cookies.get(url)) {\n    headers.cookie = cookies;\n  }\n  if (options.body) {\n    if (options.contentType !== false) {\n      headers['Content-Type'] = options.contentType || 'application/x-www-form-urlencoded';\n    }\n    if (typeof options.body.pipe === 'function') {\n      // it's a stream\n      headers['Transfer-Encoding'] = 'chunked';\n      body = options.body;\n      body.on('error', err => {\n        if (finished) {\n          return;\n        }\n        finished = true;\n        err.type = 'FETCH';\n        err.sourceUrl = url;\n        fetchRes.emit('error', err);\n      });\n    } else {\n      if (options.body instanceof Buffer) {\n        body = options.body;\n      } else if (typeof options.body === 'object') {\n        try {\n          // encodeURIComponent can fail on invalid input (partial emoji etc.)\n          body = Buffer.from(Object.keys(options.body).map(key => {\n            let value = options.body[key].toString().trim();\n            return encodeURIComponent(key) + '=' + encodeURIComponent(value);\n          }).join('&'));\n        } catch (E) {\n          if (finished) {\n            return;\n          }\n          finished = true;\n          E.type = 'FETCH';\n          E.sourceUrl = url;\n          fetchRes.emit('error', E);\n          return;\n        }\n      } else {\n        body = Buffer.from(options.body.toString().trim());\n      }\n      headers['Content-Type'] = options.contentType || 'application/x-www-form-urlencoded';\n      headers['Content-Length'] = body.length;\n    }\n    // if method is not provided, use POST instead of GET\n    method = (options.method || '').toString().trim().toUpperCase() || 'POST';\n  }\n  let req;\n  let reqOptions = {\n    method,\n    host: parsed.hostname,\n    path: parsed.path,\n    port: parsed.port ? parsed.port : parsed.protocol === 'https:' ? 443 : 80,\n    headers,\n    rejectUnauthorized: false,\n    agent: false\n  };\n  if (options.tls) {\n    Object.keys(options.tls).forEach(key => {\n      reqOptions[key] = options.tls[key];\n    });\n  }\n  if (parsed.protocol === 'https:' && parsed.hostname && parsed.hostname !== reqOptions.host && !net.isIP(parsed.hostname) && !reqOptions.servername) {\n    reqOptions.servername = parsed.hostname;\n  }\n  try {\n    req = handler.request(reqOptions);\n  } catch (E) {\n    finished = true;\n    setImmediate(() => {\n      E.type = 'FETCH';\n      E.sourceUrl = url;\n      fetchRes.emit('error', E);\n    });\n    return fetchRes;\n  }\n  if (options.timeout) {\n    req.setTimeout(options.timeout, () => {\n      if (finished) {\n        return;\n      }\n      finished = true;\n      req.abort();\n      let err = new Error('Request Timeout');\n      err.type = 'FETCH';\n      err.sourceUrl = url;\n      fetchRes.emit('error', err);\n    });\n  }\n  req.on('error', err => {\n    if (finished) {\n      return;\n    }\n    finished = true;\n    err.type = 'FETCH';\n    err.sourceUrl = url;\n    fetchRes.emit('error', err);\n  });\n  req.on('response', res => {\n    let inflate;\n    if (finished) {\n      return;\n    }\n    switch (res.headers['content-encoding']) {\n      case 'gzip':\n      case 'deflate':\n        inflate = zlib.createUnzip();\n        break;\n    }\n    if (res.headers['set-cookie']) {\n      [].concat(res.headers['set-cookie'] || []).forEach(cookie => {\n        options.cookies.set(cookie, url);\n      });\n    }\n    if ([301, 302, 303, 307, 308].includes(res.statusCode) && res.headers.location) {\n      // redirect\n      options.redirects++;\n      if (options.redirects > options.maxRedirects) {\n        finished = true;\n        let err = new Error('Maximum redirect count exceeded');\n        err.type = 'FETCH';\n        err.sourceUrl = url;\n        fetchRes.emit('error', err);\n        req.abort();\n        return;\n      }\n      // redirect does not include POST body\n      options.method = 'GET';\n      options.body = false;\n      return nmfetch(urllib.resolve(url, res.headers.location), options);\n    }\n    fetchRes.statusCode = res.statusCode;\n    fetchRes.headers = res.headers;\n    if (res.statusCode >= 300 && !options.allowErrorResponse) {\n      finished = true;\n      let err = new Error('Invalid status code ' + res.statusCode);\n      err.type = 'FETCH';\n      err.sourceUrl = url;\n      fetchRes.emit('error', err);\n      req.abort();\n      return;\n    }\n    res.on('error', err => {\n      if (finished) {\n        return;\n      }\n      finished = true;\n      err.type = 'FETCH';\n      err.sourceUrl = url;\n      fetchRes.emit('error', err);\n      req.abort();\n    });\n    if (inflate) {\n      res.pipe(inflate).pipe(fetchRes);\n      inflate.on('error', err => {\n        if (finished) {\n          return;\n        }\n        finished = true;\n        err.type = 'FETCH';\n        err.sourceUrl = url;\n        fetchRes.emit('error', err);\n        req.abort();\n      });\n    } else {\n      res.pipe(fetchRes);\n    }\n  });\n  setImmediate(() => {\n    if (body) {\n      try {\n        if (typeof body.pipe === 'function') {\n          return body.pipe(req);\n        } else {\n          req.write(body);\n        }\n      } catch (err) {\n        finished = true;\n        err.type = 'FETCH';\n        err.sourceUrl = url;\n        fetchRes.emit('error', err);\n        return;\n      }\n    }\n    req.end();\n  });\n  return fetchRes;\n}","map":{"version":3,"names":["http","require","https","urllib","zlib","PassThrough","Cookies","packageData","net","MAX_REDIRECTS","module","exports","url","options","nmfetch","fetchRes","cookies","redirects","maxRedirects","isNaN","cookie","concat","forEach","set","parsed","parse","method","toString","trim","toUpperCase","finished","body","handler","protocol","headers","version","Object","keys","key","toLowerCase","userAgent","auth","Authorization","Buffer","from","get","contentType","pipe","on","err","type","sourceUrl","emit","map","value","encodeURIComponent","join","E","length","req","reqOptions","host","hostname","path","port","rejectUnauthorized","agent","tls","isIP","servername","request","setImmediate","timeout","setTimeout","abort","Error","res","inflate","createUnzip","includes","statusCode","location","resolve","allowErrorResponse","write","end"],"sources":["C:/Users/deiby/Desktop/cloneWebCursos/paginacursos/node_modules/nodemailer/lib/fetch/index.js"],"sourcesContent":["'use strict';\n\nconst http = require('http');\nconst https = require('https');\nconst urllib = require('url');\nconst zlib = require('zlib');\nconst PassThrough = require('stream').PassThrough;\nconst Cookies = require('./cookies');\nconst packageData = require('../../package.json');\nconst net = require('net');\n\nconst MAX_REDIRECTS = 5;\n\nmodule.exports = function (url, options) {\n    return nmfetch(url, options);\n};\n\nmodule.exports.Cookies = Cookies;\n\nfunction nmfetch(url, options) {\n    options = options || {};\n\n    options.fetchRes = options.fetchRes || new PassThrough();\n    options.cookies = options.cookies || new Cookies();\n    options.redirects = options.redirects || 0;\n    options.maxRedirects = isNaN(options.maxRedirects) ? MAX_REDIRECTS : options.maxRedirects;\n\n    if (options.cookie) {\n        [].concat(options.cookie || []).forEach(cookie => {\n            options.cookies.set(cookie, url);\n        });\n        options.cookie = false;\n    }\n\n    let fetchRes = options.fetchRes;\n    let parsed = urllib.parse(url);\n    let method = (options.method || '').toString().trim().toUpperCase() || 'GET';\n    let finished = false;\n    let cookies;\n    let body;\n\n    let handler = parsed.protocol === 'https:' ? https : http;\n\n    let headers = {\n        'accept-encoding': 'gzip,deflate',\n        'user-agent': 'nodemailer/' + packageData.version\n    };\n\n    Object.keys(options.headers || {}).forEach(key => {\n        headers[key.toLowerCase().trim()] = options.headers[key];\n    });\n\n    if (options.userAgent) {\n        headers['user-agent'] = options.userAgent;\n    }\n\n    if (parsed.auth) {\n        headers.Authorization = 'Basic ' + Buffer.from(parsed.auth).toString('base64');\n    }\n\n    if ((cookies = options.cookies.get(url))) {\n        headers.cookie = cookies;\n    }\n\n    if (options.body) {\n        if (options.contentType !== false) {\n            headers['Content-Type'] = options.contentType || 'application/x-www-form-urlencoded';\n        }\n\n        if (typeof options.body.pipe === 'function') {\n            // it's a stream\n            headers['Transfer-Encoding'] = 'chunked';\n            body = options.body;\n            body.on('error', err => {\n                if (finished) {\n                    return;\n                }\n                finished = true;\n                err.type = 'FETCH';\n                err.sourceUrl = url;\n                fetchRes.emit('error', err);\n            });\n        } else {\n            if (options.body instanceof Buffer) {\n                body = options.body;\n            } else if (typeof options.body === 'object') {\n                try {\n                    // encodeURIComponent can fail on invalid input (partial emoji etc.)\n                    body = Buffer.from(\n                        Object.keys(options.body)\n                            .map(key => {\n                                let value = options.body[key].toString().trim();\n                                return encodeURIComponent(key) + '=' + encodeURIComponent(value);\n                            })\n                            .join('&')\n                    );\n                } catch (E) {\n                    if (finished) {\n                        return;\n                    }\n                    finished = true;\n                    E.type = 'FETCH';\n                    E.sourceUrl = url;\n                    fetchRes.emit('error', E);\n                    return;\n                }\n            } else {\n                body = Buffer.from(options.body.toString().trim());\n            }\n\n            headers['Content-Type'] = options.contentType || 'application/x-www-form-urlencoded';\n            headers['Content-Length'] = body.length;\n        }\n        // if method is not provided, use POST instead of GET\n        method = (options.method || '').toString().trim().toUpperCase() || 'POST';\n    }\n\n    let req;\n    let reqOptions = {\n        method,\n        host: parsed.hostname,\n        path: parsed.path,\n        port: parsed.port ? parsed.port : parsed.protocol === 'https:' ? 443 : 80,\n        headers,\n        rejectUnauthorized: false,\n        agent: false\n    };\n\n    if (options.tls) {\n        Object.keys(options.tls).forEach(key => {\n            reqOptions[key] = options.tls[key];\n        });\n    }\n\n    if (parsed.protocol === 'https:' && parsed.hostname && parsed.hostname !== reqOptions.host && !net.isIP(parsed.hostname) && !reqOptions.servername) {\n        reqOptions.servername = parsed.hostname;\n    }\n\n    try {\n        req = handler.request(reqOptions);\n    } catch (E) {\n        finished = true;\n        setImmediate(() => {\n            E.type = 'FETCH';\n            E.sourceUrl = url;\n            fetchRes.emit('error', E);\n        });\n        return fetchRes;\n    }\n\n    if (options.timeout) {\n        req.setTimeout(options.timeout, () => {\n            if (finished) {\n                return;\n            }\n            finished = true;\n            req.abort();\n            let err = new Error('Request Timeout');\n            err.type = 'FETCH';\n            err.sourceUrl = url;\n            fetchRes.emit('error', err);\n        });\n    }\n\n    req.on('error', err => {\n        if (finished) {\n            return;\n        }\n        finished = true;\n        err.type = 'FETCH';\n        err.sourceUrl = url;\n        fetchRes.emit('error', err);\n    });\n\n    req.on('response', res => {\n        let inflate;\n\n        if (finished) {\n            return;\n        }\n\n        switch (res.headers['content-encoding']) {\n            case 'gzip':\n            case 'deflate':\n                inflate = zlib.createUnzip();\n                break;\n        }\n\n        if (res.headers['set-cookie']) {\n            [].concat(res.headers['set-cookie'] || []).forEach(cookie => {\n                options.cookies.set(cookie, url);\n            });\n        }\n\n        if ([301, 302, 303, 307, 308].includes(res.statusCode) && res.headers.location) {\n            // redirect\n            options.redirects++;\n            if (options.redirects > options.maxRedirects) {\n                finished = true;\n                let err = new Error('Maximum redirect count exceeded');\n                err.type = 'FETCH';\n                err.sourceUrl = url;\n                fetchRes.emit('error', err);\n                req.abort();\n                return;\n            }\n            // redirect does not include POST body\n            options.method = 'GET';\n            options.body = false;\n            return nmfetch(urllib.resolve(url, res.headers.location), options);\n        }\n\n        fetchRes.statusCode = res.statusCode;\n        fetchRes.headers = res.headers;\n\n        if (res.statusCode >= 300 && !options.allowErrorResponse) {\n            finished = true;\n            let err = new Error('Invalid status code ' + res.statusCode);\n            err.type = 'FETCH';\n            err.sourceUrl = url;\n            fetchRes.emit('error', err);\n            req.abort();\n            return;\n        }\n\n        res.on('error', err => {\n            if (finished) {\n                return;\n            }\n            finished = true;\n            err.type = 'FETCH';\n            err.sourceUrl = url;\n            fetchRes.emit('error', err);\n            req.abort();\n        });\n\n        if (inflate) {\n            res.pipe(inflate).pipe(fetchRes);\n            inflate.on('error', err => {\n                if (finished) {\n                    return;\n                }\n                finished = true;\n                err.type = 'FETCH';\n                err.sourceUrl = url;\n                fetchRes.emit('error', err);\n                req.abort();\n            });\n        } else {\n            res.pipe(fetchRes);\n        }\n    });\n\n    setImmediate(() => {\n        if (body) {\n            try {\n                if (typeof body.pipe === 'function') {\n                    return body.pipe(req);\n                } else {\n                    req.write(body);\n                }\n            } catch (err) {\n                finished = true;\n                err.type = 'FETCH';\n                err.sourceUrl = url;\n                fetchRes.emit('error', err);\n                return;\n            }\n        }\n        req.end();\n    });\n\n    return fetchRes;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}