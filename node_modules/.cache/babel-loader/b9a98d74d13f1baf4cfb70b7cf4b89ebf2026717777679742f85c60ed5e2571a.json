{"ast":null,"code":"/* eslint no-undefined: 0, prefer-spread: 0, no-control-regex: 0 */\n\n'use strict';\n\nconst crypto = require('crypto');\nconst fs = require('fs');\nconst punycode = require('punycode');\nconst PassThrough = require('stream').PassThrough;\nconst shared = require('../shared');\nconst mimeFuncs = require('../mime-funcs');\nconst qp = require('../qp');\nconst base64 = require('../base64');\nconst addressparser = require('../addressparser');\nconst nmfetch = require('../fetch');\nconst LastNewline = require('./last-newline');\nconst LeWindows = require('./le-windows');\nconst LeUnix = require('./le-unix');\n\n/**\n * Creates a new mime tree node. Assumes 'multipart/*' as the content type\n * if it is a branch, anything else counts as leaf. If rootNode is missing from\n * the options, assumes this is the root.\n *\n * @param {String} contentType Define the content type for the node. Can be left blank for attachments (derived from filename)\n * @param {Object} [options] optional options\n * @param {Object} [options.rootNode] root node for this tree\n * @param {Object} [options.parentNode] immediate parent for this node\n * @param {Object} [options.filename] filename for an attachment node\n * @param {String} [options.baseBoundary] shared part of the unique multipart boundary\n * @param {Boolean} [options.keepBcc] If true, do not exclude Bcc from the generated headers\n * @param {Function} [options.normalizeHeaderKey] method to normalize header keys for custom caseing\n * @param {String} [options.textEncoding] either 'Q' (the default) or 'B'\n */\nclass MimeNode {\n  constructor(contentType, options) {\n    this.nodeCounter = 0;\n    options = options || {};\n\n    /**\n     * shared part of the unique multipart boundary\n     */\n    this.baseBoundary = options.baseBoundary || crypto.randomBytes(8).toString('hex');\n    this.boundaryPrefix = options.boundaryPrefix || '--_NmP';\n    this.disableFileAccess = !!options.disableFileAccess;\n    this.disableUrlAccess = !!options.disableUrlAccess;\n    this.normalizeHeaderKey = options.normalizeHeaderKey;\n\n    /**\n     * If date headers is missing and current node is the root, this value is used instead\n     */\n    this.date = new Date();\n\n    /**\n     * Root node for current mime tree\n     */\n    this.rootNode = options.rootNode || this;\n\n    /**\n     * If true include Bcc in generated headers (if available)\n     */\n    this.keepBcc = !!options.keepBcc;\n\n    /**\n     * If filename is specified but contentType is not (probably an attachment)\n     * detect the content type from filename extension\n     */\n    if (options.filename) {\n      /**\n       * Filename for this node. Useful with attachments\n       */\n      this.filename = options.filename;\n      if (!contentType) {\n        contentType = mimeFuncs.detectMimeType(this.filename.split('.').pop());\n      }\n    }\n\n    /**\n     * Indicates which encoding should be used for header strings: \"Q\" or \"B\"\n     */\n    this.textEncoding = (options.textEncoding || '').toString().trim().charAt(0).toUpperCase();\n\n    /**\n     * Immediate parent for this node (or undefined if not set)\n     */\n    this.parentNode = options.parentNode;\n\n    /**\n     * Hostname for default message-id values\n     */\n    this.hostname = options.hostname;\n\n    /**\n     * If set to 'win' then uses \\r\\n, if 'linux' then \\n. If not set (or `raw` is used) then newlines are kept as is.\n     */\n    this.newline = options.newline;\n\n    /**\n     * An array for possible child nodes\n     */\n    this.childNodes = [];\n\n    /**\n     * Used for generating unique boundaries (prepended to the shared base)\n     */\n    this._nodeId = ++this.rootNode.nodeCounter;\n\n    /**\n     * A list of header values for this node in the form of [{key:'', value:''}]\n     */\n    this._headers = [];\n\n    /**\n     * True if the content only uses ASCII printable characters\n     * @type {Boolean}\n     */\n    this._isPlainText = false;\n\n    /**\n     * True if the content is plain text but has longer lines than allowed\n     * @type {Boolean}\n     */\n    this._hasLongLines = false;\n\n    /**\n     * If set, use instead this value for envelopes instead of generating one\n     * @type {Boolean}\n     */\n    this._envelope = false;\n\n    /**\n     * If set then use this value as the stream content instead of building it\n     * @type {String|Buffer|Stream}\n     */\n    this._raw = false;\n\n    /**\n     * Additional transform streams that the message will be piped before\n     * exposing by createReadStream\n     * @type {Array}\n     */\n    this._transforms = [];\n\n    /**\n     * Additional process functions that the message will be piped through before\n     * exposing by createReadStream. These functions are run after transforms\n     * @type {Array}\n     */\n    this._processFuncs = [];\n\n    /**\n     * If content type is set (or derived from the filename) add it to headers\n     */\n    if (contentType) {\n      this.setHeader('Content-Type', contentType);\n    }\n  }\n\n  /////// PUBLIC METHODS\n\n  /**\n   * Creates and appends a child node.Arguments provided are passed to MimeNode constructor\n   *\n   * @param {String} [contentType] Optional content type\n   * @param {Object} [options] Optional options object\n   * @return {Object} Created node object\n   */\n  createChild(contentType, options) {\n    if (!options && typeof contentType === 'object') {\n      options = contentType;\n      contentType = undefined;\n    }\n    let node = new MimeNode(contentType, options);\n    this.appendChild(node);\n    return node;\n  }\n\n  /**\n   * Appends an existing node to the mime tree. Removes the node from an existing\n   * tree if needed\n   *\n   * @param {Object} childNode node to be appended\n   * @return {Object} Appended node object\n   */\n  appendChild(childNode) {\n    if (childNode.rootNode !== this.rootNode) {\n      childNode.rootNode = this.rootNode;\n      childNode._nodeId = ++this.rootNode.nodeCounter;\n    }\n    childNode.parentNode = this;\n    this.childNodes.push(childNode);\n    return childNode;\n  }\n\n  /**\n   * Replaces current node with another node\n   *\n   * @param {Object} node Replacement node\n   * @return {Object} Replacement node\n   */\n  replace(node) {\n    if (node === this) {\n      return this;\n    }\n    this.parentNode.childNodes.forEach((childNode, i) => {\n      if (childNode === this) {\n        node.rootNode = this.rootNode;\n        node.parentNode = this.parentNode;\n        node._nodeId = this._nodeId;\n        this.rootNode = this;\n        this.parentNode = undefined;\n        node.parentNode.childNodes[i] = node;\n      }\n    });\n    return node;\n  }\n\n  /**\n   * Removes current node from the mime tree\n   *\n   * @return {Object} removed node\n   */\n  remove() {\n    if (!this.parentNode) {\n      return this;\n    }\n    for (let i = this.parentNode.childNodes.length - 1; i >= 0; i--) {\n      if (this.parentNode.childNodes[i] === this) {\n        this.parentNode.childNodes.splice(i, 1);\n        this.parentNode = undefined;\n        this.rootNode = this;\n        return this;\n      }\n    }\n  }\n\n  /**\n   * Sets a header value. If the value for selected key exists, it is overwritten.\n   * You can set multiple values as well by using [{key:'', value:''}] or\n   * {key: 'value'} as the first argument.\n   *\n   * @param {String|Array|Object} key Header key or a list of key value pairs\n   * @param {String} value Header value\n   * @return {Object} current node\n   */\n  setHeader(key, value) {\n    let added = false,\n      headerValue;\n\n    // Allow setting multiple headers at once\n    if (!value && key && typeof key === 'object') {\n      // allow {key:'content-type', value: 'text/plain'}\n      if (key.key && 'value' in key) {\n        this.setHeader(key.key, key.value);\n      } else if (Array.isArray(key)) {\n        // allow [{key:'content-type', value: 'text/plain'}]\n        key.forEach(i => {\n          this.setHeader(i.key, i.value);\n        });\n      } else {\n        // allow {'content-type': 'text/plain'}\n        Object.keys(key).forEach(i => {\n          this.setHeader(i, key[i]);\n        });\n      }\n      return this;\n    }\n    key = this._normalizeHeaderKey(key);\n    headerValue = {\n      key,\n      value\n    };\n\n    // Check if the value exists and overwrite\n    for (let i = 0, len = this._headers.length; i < len; i++) {\n      if (this._headers[i].key === key) {\n        if (!added) {\n          // replace the first match\n          this._headers[i] = headerValue;\n          added = true;\n        } else {\n          // remove following matches\n          this._headers.splice(i, 1);\n          i--;\n          len--;\n        }\n      }\n    }\n\n    // match not found, append the value\n    if (!added) {\n      this._headers.push(headerValue);\n    }\n    return this;\n  }\n\n  /**\n   * Adds a header value. If the value for selected key exists, the value is appended\n   * as a new field and old one is not touched.\n   * You can set multiple values as well by using [{key:'', value:''}] or\n   * {key: 'value'} as the first argument.\n   *\n   * @param {String|Array|Object} key Header key or a list of key value pairs\n   * @param {String} value Header value\n   * @return {Object} current node\n   */\n  addHeader(key, value) {\n    // Allow setting multiple headers at once\n    if (!value && key && typeof key === 'object') {\n      // allow {key:'content-type', value: 'text/plain'}\n      if (key.key && key.value) {\n        this.addHeader(key.key, key.value);\n      } else if (Array.isArray(key)) {\n        // allow [{key:'content-type', value: 'text/plain'}]\n        key.forEach(i => {\n          this.addHeader(i.key, i.value);\n        });\n      } else {\n        // allow {'content-type': 'text/plain'}\n        Object.keys(key).forEach(i => {\n          this.addHeader(i, key[i]);\n        });\n      }\n      return this;\n    } else if (Array.isArray(value)) {\n      value.forEach(val => {\n        this.addHeader(key, val);\n      });\n      return this;\n    }\n    this._headers.push({\n      key: this._normalizeHeaderKey(key),\n      value\n    });\n    return this;\n  }\n\n  /**\n   * Retrieves the first mathcing value of a selected key\n   *\n   * @param {String} key Key to search for\n   * @retun {String} Value for the key\n   */\n  getHeader(key) {\n    key = this._normalizeHeaderKey(key);\n    for (let i = 0, len = this._headers.length; i < len; i++) {\n      if (this._headers[i].key === key) {\n        return this._headers[i].value;\n      }\n    }\n  }\n\n  /**\n   * Sets body content for current node. If the value is a string, charset is added automatically\n   * to Content-Type (if it is text/*). If the value is a Buffer, you need to specify\n   * the charset yourself\n   *\n   * @param (String|Buffer) content Body content\n   * @return {Object} current node\n   */\n  setContent(content) {\n    this.content = content;\n    if (typeof this.content.pipe === 'function') {\n      // pre-stream handler. might be triggered if a stream is set as content\n      // and 'error' fires before anything is done with this stream\n      this._contentErrorHandler = err => {\n        this.content.removeListener('error', this._contentErrorHandler);\n        this.content = err;\n      };\n      this.content.once('error', this._contentErrorHandler);\n    } else if (typeof this.content === 'string') {\n      this._isPlainText = mimeFuncs.isPlainText(this.content);\n      if (this._isPlainText && mimeFuncs.hasLongerLines(this.content, 76)) {\n        // If there are lines longer than 76 symbols/bytes do not use 7bit\n        this._hasLongLines = true;\n      }\n    }\n    return this;\n  }\n  build(callback) {\n    let promise;\n    if (!callback) {\n      promise = new Promise((resolve, reject) => {\n        callback = shared.callbackPromise(resolve, reject);\n      });\n    }\n    let stream = this.createReadStream();\n    let buf = [];\n    let buflen = 0;\n    let returned = false;\n    stream.on('readable', () => {\n      let chunk;\n      while ((chunk = stream.read()) !== null) {\n        buf.push(chunk);\n        buflen += chunk.length;\n      }\n    });\n    stream.once('error', err => {\n      if (returned) {\n        return;\n      }\n      returned = true;\n      return callback(err);\n    });\n    stream.once('end', chunk => {\n      if (returned) {\n        return;\n      }\n      returned = true;\n      if (chunk && chunk.length) {\n        buf.push(chunk);\n        buflen += chunk.length;\n      }\n      return callback(null, Buffer.concat(buf, buflen));\n    });\n    return promise;\n  }\n  getTransferEncoding() {\n    let transferEncoding = false;\n    let contentType = (this.getHeader('Content-Type') || '').toString().toLowerCase().trim();\n    if (this.content) {\n      transferEncoding = (this.getHeader('Content-Transfer-Encoding') || '').toString().toLowerCase().trim();\n      if (!transferEncoding || !['base64', 'quoted-printable'].includes(transferEncoding)) {\n        if (/^text\\//i.test(contentType)) {\n          // If there are no special symbols, no need to modify the text\n          if (this._isPlainText && !this._hasLongLines) {\n            transferEncoding = '7bit';\n          } else if (typeof this.content === 'string' || this.content instanceof Buffer) {\n            // detect preferred encoding for string value\n            transferEncoding = this._getTextEncoding(this.content) === 'Q' ? 'quoted-printable' : 'base64';\n          } else {\n            // we can not check content for a stream, so either use preferred encoding or fallback to QP\n            transferEncoding = this.textEncoding === 'B' ? 'base64' : 'quoted-printable';\n          }\n        } else if (!/^(multipart|message)\\//i.test(contentType)) {\n          transferEncoding = transferEncoding || 'base64';\n        }\n      }\n    }\n    return transferEncoding;\n  }\n\n  /**\n   * Builds the header block for the mime node. Append \\r\\n\\r\\n before writing the content\n   *\n   * @returns {String} Headers\n   */\n  buildHeaders() {\n    let transferEncoding = this.getTransferEncoding();\n    let headers = [];\n    if (transferEncoding) {\n      this.setHeader('Content-Transfer-Encoding', transferEncoding);\n    }\n    if (this.filename && !this.getHeader('Content-Disposition')) {\n      this.setHeader('Content-Disposition', 'attachment');\n    }\n\n    // Ensure mandatory header fields\n    if (this.rootNode === this) {\n      if (!this.getHeader('Date')) {\n        this.setHeader('Date', this.date.toUTCString().replace(/GMT/, '+0000'));\n      }\n\n      // ensure that Message-Id is present\n      this.messageId();\n      if (!this.getHeader('MIME-Version')) {\n        this.setHeader('MIME-Version', '1.0');\n      }\n    }\n    this._headers.forEach(header => {\n      let key = header.key;\n      let value = header.value;\n      let structured;\n      let param;\n      let options = {};\n      let formattedHeaders = ['From', 'Sender', 'To', 'Cc', 'Bcc', 'Reply-To', 'Date', 'References'];\n      if (value && typeof value === 'object' && !formattedHeaders.includes(key)) {\n        Object.keys(value).forEach(key => {\n          if (key !== 'value') {\n            options[key] = value[key];\n          }\n        });\n        value = (value.value || '').toString();\n        if (!value.trim()) {\n          return;\n        }\n      }\n      if (options.prepared) {\n        // header value is\n        if (options.foldLines) {\n          headers.push(mimeFuncs.foldLines(key + ': ' + value));\n        } else {\n          headers.push(key + ': ' + value);\n        }\n        return;\n      }\n      switch (header.key) {\n        case 'Content-Disposition':\n          structured = mimeFuncs.parseHeaderValue(value);\n          if (this.filename) {\n            structured.params.filename = this.filename;\n          }\n          value = mimeFuncs.buildHeaderValue(structured);\n          break;\n        case 'Content-Type':\n          structured = mimeFuncs.parseHeaderValue(value);\n          this._handleContentType(structured);\n          if (structured.value.match(/^text\\/plain\\b/) && typeof this.content === 'string' && /[\\u0080-\\uFFFF]/.test(this.content)) {\n            structured.params.charset = 'utf-8';\n          }\n          value = mimeFuncs.buildHeaderValue(structured);\n          if (this.filename) {\n            // add support for non-compliant clients like QQ webmail\n            // we can't build the value with buildHeaderValue as the value is non standard and\n            // would be converted to parameter continuation encoding that we do not want\n            param = this._encodeWords(this.filename);\n            if (param !== this.filename || /[\\s'\"\\\\;:/=(),<>@[\\]?]|^-/.test(param)) {\n              // include value in quotes if needed\n              param = '\"' + param + '\"';\n            }\n            value += '; name=' + param;\n          }\n          break;\n        case 'Bcc':\n          if (!this.keepBcc) {\n            // skip BCC values\n            return;\n          }\n          break;\n      }\n      value = this._encodeHeaderValue(key, value);\n\n      // skip empty lines\n      if (!(value || '').toString().trim()) {\n        return;\n      }\n      if (typeof this.normalizeHeaderKey === 'function') {\n        let normalized = this.normalizeHeaderKey(key, value);\n        if (normalized && typeof normalized === 'string' && normalized.length) {\n          key = normalized;\n        }\n      }\n      headers.push(mimeFuncs.foldLines(key + ': ' + value, 76));\n    });\n    return headers.join('\\r\\n');\n  }\n\n  /**\n   * Streams the rfc2822 message from the current node. If this is a root node,\n   * mandatory header fields are set if missing (Date, Message-Id, MIME-Version)\n   *\n   * @return {String} Compiled message\n   */\n  createReadStream(options) {\n    options = options || {};\n    let stream = new PassThrough(options);\n    let outputStream = stream;\n    let transform;\n    this.stream(stream, options, err => {\n      if (err) {\n        outputStream.emit('error', err);\n        return;\n      }\n      stream.end();\n    });\n    for (let i = 0, len = this._transforms.length; i < len; i++) {\n      transform = typeof this._transforms[i] === 'function' ? this._transforms[i]() : this._transforms[i];\n      outputStream.once('error', err => {\n        transform.emit('error', err);\n      });\n      outputStream = outputStream.pipe(transform);\n    }\n\n    // ensure terminating newline after possible user transforms\n    transform = new LastNewline();\n    outputStream.once('error', err => {\n      transform.emit('error', err);\n    });\n    outputStream = outputStream.pipe(transform);\n\n    // dkim and stuff\n    for (let i = 0, len = this._processFuncs.length; i < len; i++) {\n      transform = this._processFuncs[i];\n      outputStream = transform(outputStream);\n    }\n    if (this.newline) {\n      const winbreak = ['win', 'windows', 'dos', '\\r\\n'].includes(this.newline.toString().toLowerCase());\n      const newlineTransform = winbreak ? new LeWindows() : new LeUnix();\n      const stream = outputStream.pipe(newlineTransform);\n      outputStream.on('error', err => stream.emit('error', err));\n      return stream;\n    }\n    return outputStream;\n  }\n\n  /**\n   * Appends a transform stream object to the transforms list. Final output\n   * is passed through this stream before exposing\n   *\n   * @param {Object} transform Read-Write stream\n   */\n  transform(transform) {\n    this._transforms.push(transform);\n  }\n\n  /**\n   * Appends a post process function. The functon is run after transforms and\n   * uses the following syntax\n   *\n   *   processFunc(input) -> outputStream\n   *\n   * @param {Object} processFunc Read-Write stream\n   */\n  processFunc(processFunc) {\n    this._processFuncs.push(processFunc);\n  }\n  stream(outputStream, options, done) {\n    let transferEncoding = this.getTransferEncoding();\n    let contentStream;\n    let localStream;\n\n    // protect actual callback against multiple triggering\n    let returned = false;\n    let callback = err => {\n      if (returned) {\n        return;\n      }\n      returned = true;\n      done(err);\n    };\n\n    // for multipart nodes, push child nodes\n    // for content nodes end the stream\n    let finalize = () => {\n      let childId = 0;\n      let processChildNode = () => {\n        if (childId >= this.childNodes.length) {\n          outputStream.write('\\r\\n--' + this.boundary + '--\\r\\n');\n          return callback();\n        }\n        let child = this.childNodes[childId++];\n        outputStream.write((childId > 1 ? '\\r\\n' : '') + '--' + this.boundary + '\\r\\n');\n        child.stream(outputStream, options, err => {\n          if (err) {\n            return callback(err);\n          }\n          setImmediate(processChildNode);\n        });\n      };\n      if (this.multipart) {\n        setImmediate(processChildNode);\n      } else {\n        return callback();\n      }\n    };\n\n    // pushes node content\n    let sendContent = () => {\n      if (this.content) {\n        if (Object.prototype.toString.call(this.content) === '[object Error]') {\n          // content is already errored\n          return callback(this.content);\n        }\n        if (typeof this.content.pipe === 'function') {\n          this.content.removeListener('error', this._contentErrorHandler);\n          this._contentErrorHandler = err => callback(err);\n          this.content.once('error', this._contentErrorHandler);\n        }\n        let createStream = () => {\n          if (['quoted-printable', 'base64'].includes(transferEncoding)) {\n            contentStream = new (transferEncoding === 'base64' ? base64 : qp).Encoder(options);\n            contentStream.pipe(outputStream, {\n              end: false\n            });\n            contentStream.once('end', finalize);\n            contentStream.once('error', err => callback(err));\n            localStream = this._getStream(this.content);\n            localStream.pipe(contentStream);\n          } else {\n            // anything that is not QP or Base54 passes as-is\n            localStream = this._getStream(this.content);\n            localStream.pipe(outputStream, {\n              end: false\n            });\n            localStream.once('end', finalize);\n          }\n          localStream.once('error', err => callback(err));\n        };\n        if (this.content._resolve) {\n          let chunks = [];\n          let chunklen = 0;\n          let returned = false;\n          let sourceStream = this._getStream(this.content);\n          sourceStream.on('error', err => {\n            if (returned) {\n              return;\n            }\n            returned = true;\n            callback(err);\n          });\n          sourceStream.on('readable', () => {\n            let chunk;\n            while ((chunk = sourceStream.read()) !== null) {\n              chunks.push(chunk);\n              chunklen += chunk.length;\n            }\n          });\n          sourceStream.on('end', () => {\n            if (returned) {\n              return;\n            }\n            returned = true;\n            this.content._resolve = false;\n            this.content._resolvedValue = Buffer.concat(chunks, chunklen);\n            setImmediate(createStream);\n          });\n        } else {\n          setImmediate(createStream);\n        }\n        return;\n      } else {\n        return setImmediate(finalize);\n      }\n    };\n    if (this._raw) {\n      setImmediate(() => {\n        if (Object.prototype.toString.call(this._raw) === '[object Error]') {\n          // content is already errored\n          return callback(this._raw);\n        }\n\n        // remove default error handler (if set)\n        if (typeof this._raw.pipe === 'function') {\n          this._raw.removeListener('error', this._contentErrorHandler);\n        }\n        let raw = this._getStream(this._raw);\n        raw.pipe(outputStream, {\n          end: false\n        });\n        raw.on('error', err => outputStream.emit('error', err));\n        raw.on('end', finalize);\n      });\n    } else {\n      outputStream.write(this.buildHeaders() + '\\r\\n\\r\\n');\n      setImmediate(sendContent);\n    }\n  }\n\n  /**\n   * Sets envelope to be used instead of the generated one\n   *\n   * @return {Object} SMTP envelope in the form of {from: 'from@example.com', to: ['to@example.com']}\n   */\n  setEnvelope(envelope) {\n    let list;\n    this._envelope = {\n      from: false,\n      to: []\n    };\n    if (envelope.from) {\n      list = [];\n      this._convertAddresses(this._parseAddresses(envelope.from), list);\n      list = list.filter(address => address && address.address);\n      if (list.length && list[0]) {\n        this._envelope.from = list[0].address;\n      }\n    }\n    ['to', 'cc', 'bcc'].forEach(key => {\n      if (envelope[key]) {\n        this._convertAddresses(this._parseAddresses(envelope[key]), this._envelope.to);\n      }\n    });\n    this._envelope.to = this._envelope.to.map(to => to.address).filter(address => address);\n    let standardFields = ['to', 'cc', 'bcc', 'from'];\n    Object.keys(envelope).forEach(key => {\n      if (!standardFields.includes(key)) {\n        this._envelope[key] = envelope[key];\n      }\n    });\n    return this;\n  }\n\n  /**\n   * Generates and returns an object with parsed address fields\n   *\n   * @return {Object} Address object\n   */\n  getAddresses() {\n    let addresses = {};\n    this._headers.forEach(header => {\n      let key = header.key.toLowerCase();\n      if (['from', 'sender', 'reply-to', 'to', 'cc', 'bcc'].includes(key)) {\n        if (!Array.isArray(addresses[key])) {\n          addresses[key] = [];\n        }\n        this._convertAddresses(this._parseAddresses(header.value), addresses[key]);\n      }\n    });\n    return addresses;\n  }\n\n  /**\n   * Generates and returns SMTP envelope with the sender address and a list of recipients addresses\n   *\n   * @return {Object} SMTP envelope in the form of {from: 'from@example.com', to: ['to@example.com']}\n   */\n  getEnvelope() {\n    if (this._envelope) {\n      return this._envelope;\n    }\n    let envelope = {\n      from: false,\n      to: []\n    };\n    this._headers.forEach(header => {\n      let list = [];\n      if (header.key === 'From' || !envelope.from && ['Reply-To', 'Sender'].includes(header.key)) {\n        this._convertAddresses(this._parseAddresses(header.value), list);\n        if (list.length && list[0]) {\n          envelope.from = list[0].address;\n        }\n      } else if (['To', 'Cc', 'Bcc'].includes(header.key)) {\n        this._convertAddresses(this._parseAddresses(header.value), envelope.to);\n      }\n    });\n    envelope.to = envelope.to.map(to => to.address);\n    return envelope;\n  }\n\n  /**\n   * Returns Message-Id value. If it does not exist, then creates one\n   *\n   * @return {String} Message-Id value\n   */\n  messageId() {\n    let messageId = this.getHeader('Message-ID');\n    // You really should define your own Message-Id field!\n    if (!messageId) {\n      messageId = this._generateMessageId();\n      this.setHeader('Message-ID', messageId);\n    }\n    return messageId;\n  }\n\n  /**\n   * Sets pregenerated content that will be used as the output of this node\n   *\n   * @param {String|Buffer|Stream} Raw MIME contents\n   */\n  setRaw(raw) {\n    this._raw = raw;\n    if (this._raw && typeof this._raw.pipe === 'function') {\n      // pre-stream handler. might be triggered if a stream is set as content\n      // and 'error' fires before anything is done with this stream\n      this._contentErrorHandler = err => {\n        this._raw.removeListener('error', this._contentErrorHandler);\n        this._raw = err;\n      };\n      this._raw.once('error', this._contentErrorHandler);\n    }\n    return this;\n  }\n\n  /////// PRIVATE METHODS\n\n  /**\n   * Detects and returns handle to a stream related with the content.\n   *\n   * @param {Mixed} content Node content\n   * @returns {Object} Stream object\n   */\n  _getStream(content) {\n    let contentStream;\n    if (content._resolvedValue) {\n      // pass string or buffer content as a stream\n      contentStream = new PassThrough();\n      setImmediate(() => contentStream.end(content._resolvedValue));\n      return contentStream;\n    } else if (typeof content.pipe === 'function') {\n      // assume as stream\n      return content;\n    } else if (content && typeof content.path === 'string' && !content.href) {\n      if (this.disableFileAccess) {\n        contentStream = new PassThrough();\n        setImmediate(() => contentStream.emit('error', new Error('File access rejected for ' + content.path)));\n        return contentStream;\n      }\n      // read file\n      return fs.createReadStream(content.path);\n    } else if (content && typeof content.href === 'string') {\n      if (this.disableUrlAccess) {\n        contentStream = new PassThrough();\n        setImmediate(() => contentStream.emit('error', new Error('Url access rejected for ' + content.href)));\n        return contentStream;\n      }\n      // fetch URL\n      return nmfetch(content.href, {\n        headers: content.httpHeaders\n      });\n    } else {\n      // pass string or buffer content as a stream\n      contentStream = new PassThrough();\n      setImmediate(() => contentStream.end(content || ''));\n      return contentStream;\n    }\n  }\n\n  /**\n   * Parses addresses. Takes in a single address or an array or an\n   * array of address arrays (eg. To: [[first group], [second group],...])\n   *\n   * @param {Mixed} addresses Addresses to be parsed\n   * @return {Array} An array of address objects\n   */\n  _parseAddresses(addresses) {\n    return [].concat.apply([], [].concat(addresses).map(address => {\n      // eslint-disable-line prefer-spread\n      if (address && address.address) {\n        address.address = this._normalizeAddress(address.address);\n        address.name = address.name || '';\n        return [address];\n      }\n      return addressparser(address);\n    }));\n  }\n\n  /**\n   * Normalizes a header key, uses Camel-Case form, except for uppercase MIME-\n   *\n   * @param {String} key Key to be normalized\n   * @return {String} key in Camel-Case form\n   */\n  _normalizeHeaderKey(key) {\n    key = (key || '').toString()\n    // no newlines in keys\n    .replace(/\\r?\\n|\\r/g, ' ').trim().toLowerCase()\n    // use uppercase words, except MIME\n    .replace(/^X-SMTPAPI$|^(MIME|DKIM|ARC|BIMI)\\b|^[a-z]|-(SPF|FBL|ID|MD5)$|-[a-z]/gi, c => c.toUpperCase())\n    // special case\n    .replace(/^Content-Features$/i, 'Content-features');\n    return key;\n  }\n\n  /**\n   * Checks if the content type is multipart and defines boundary if needed.\n   * Doesn't return anything, modifies object argument instead.\n   *\n   * @param {Object} structured Parsed header value for 'Content-Type' key\n   */\n  _handleContentType(structured) {\n    this.contentType = structured.value.trim().toLowerCase();\n    this.multipart = /^multipart\\//i.test(this.contentType) ? this.contentType.substr(this.contentType.indexOf('/') + 1) : false;\n    if (this.multipart) {\n      this.boundary = structured.params.boundary = structured.params.boundary || this.boundary || this._generateBoundary();\n    } else {\n      this.boundary = false;\n    }\n  }\n\n  /**\n   * Generates a multipart boundary value\n   *\n   * @return {String} boundary value\n   */\n  _generateBoundary() {\n    return this.rootNode.boundaryPrefix + '-' + this.rootNode.baseBoundary + '-Part_' + this._nodeId;\n  }\n\n  /**\n   * Encodes a header value for use in the generated rfc2822 email.\n   *\n   * @param {String} key Header key\n   * @param {String} value Header value\n   */\n  _encodeHeaderValue(key, value) {\n    key = this._normalizeHeaderKey(key);\n    switch (key) {\n      // Structured headers\n      case 'From':\n      case 'Sender':\n      case 'To':\n      case 'Cc':\n      case 'Bcc':\n      case 'Reply-To':\n        return this._convertAddresses(this._parseAddresses(value));\n\n      // values enclosed in <>\n      case 'Message-ID':\n      case 'In-Reply-To':\n      case 'Content-Id':\n        value = (value || '').toString().replace(/\\r?\\n|\\r/g, ' ');\n        if (value.charAt(0) !== '<') {\n          value = '<' + value;\n        }\n        if (value.charAt(value.length - 1) !== '>') {\n          value = value + '>';\n        }\n        return value;\n\n      // space separated list of values enclosed in <>\n      case 'References':\n        value = [].concat.apply([], [].concat(value || '').map(elm => {\n          // eslint-disable-line prefer-spread\n          elm = (elm || '').toString().replace(/\\r?\\n|\\r/g, ' ').trim();\n          return elm.replace(/<[^>]*>/g, str => str.replace(/\\s/g, '')).split(/\\s+/);\n        })).map(elm => {\n          if (elm.charAt(0) !== '<') {\n            elm = '<' + elm;\n          }\n          if (elm.charAt(elm.length - 1) !== '>') {\n            elm = elm + '>';\n          }\n          return elm;\n        });\n        return value.join(' ').trim();\n      case 'Date':\n        if (Object.prototype.toString.call(value) === '[object Date]') {\n          return value.toUTCString().replace(/GMT/, '+0000');\n        }\n        value = (value || '').toString().replace(/\\r?\\n|\\r/g, ' ');\n        return this._encodeWords(value);\n      case 'Content-Type':\n      case 'Content-Disposition':\n        // if it includes a filename then it is already encoded\n        return (value || '').toString().replace(/\\r?\\n|\\r/g, ' ');\n      default:\n        value = (value || '').toString().replace(/\\r?\\n|\\r/g, ' ');\n        // encodeWords only encodes if needed, otherwise the original string is returned\n        return this._encodeWords(value);\n    }\n  }\n\n  /**\n   * Rebuilds address object using punycode and other adjustments\n   *\n   * @param {Array} addresses An array of address objects\n   * @param {Array} [uniqueList] An array to be populated with addresses\n   * @return {String} address string\n   */\n  _convertAddresses(addresses, uniqueList) {\n    let values = [];\n    uniqueList = uniqueList || [];\n    [].concat(addresses || []).forEach(address => {\n      if (address.address) {\n        address.address = this._normalizeAddress(address.address);\n        if (!address.name) {\n          values.push(address.address.indexOf(' ') >= 0 ? `<${address.address}>` : `${address.address}`);\n        } else if (address.name) {\n          values.push(`${this._encodeAddressName(address.name)} <${address.address}>`);\n        }\n        if (address.address) {\n          if (!uniqueList.filter(a => a.address === address.address).length) {\n            uniqueList.push(address);\n          }\n        }\n      } else if (address.group) {\n        let groupListAddresses = (address.group.length ? this._convertAddresses(address.group, uniqueList) : '').trim();\n        values.push(`${this._encodeAddressName(address.name)}:${groupListAddresses};`);\n      }\n    });\n    return values.join(', ');\n  }\n\n  /**\n   * Normalizes an email address\n   *\n   * @param {Array} address An array of address objects\n   * @return {String} address string\n   */\n  _normalizeAddress(address) {\n    address = (address || '').toString().replace(/[\\x00-\\x1F<>]+/g, ' ') // remove unallowed characters\n    .trim();\n    let lastAt = address.lastIndexOf('@');\n    if (lastAt < 0) {\n      // Bare username\n      return address;\n    }\n    let user = address.substr(0, lastAt);\n    let domain = address.substr(lastAt + 1);\n\n    // Usernames are not touched and are kept as is even if these include unicode\n    // Domains are punycoded by default\n    // 'jõgeva.ee' will be converted to 'xn--jgeva-dua.ee'\n    // non-unicode domains are left as is\n\n    let encodedDomain;\n    try {\n      encodedDomain = punycode.toASCII(domain.toLowerCase());\n    } catch (err) {\n      // keep as is?\n    }\n    if (user.indexOf(' ') >= 0) {\n      if (user.charAt(0) !== '\"') {\n        user = '\"' + user;\n      }\n      if (user.substr(-1) !== '\"') {\n        user = user + '\"';\n      }\n    }\n    return `${user}@${encodedDomain}`;\n  }\n\n  /**\n   * If needed, mime encodes the name part\n   *\n   * @param {String} name Name part of an address\n   * @returns {String} Mime word encoded string if needed\n   */\n  _encodeAddressName(name) {\n    if (!/^[\\w ']*$/.test(name)) {\n      if (/^[\\x20-\\x7e]*$/.test(name)) {\n        return '\"' + name.replace(/([\\\\\"])/g, '\\\\$1') + '\"';\n      } else {\n        return mimeFuncs.encodeWord(name, this._getTextEncoding(name), 52);\n      }\n    }\n    return name;\n  }\n\n  /**\n   * If needed, mime encodes the name part\n   *\n   * @param {String} name Name part of an address\n   * @returns {String} Mime word encoded string if needed\n   */\n  _encodeWords(value) {\n    // set encodeAll parameter to true even though it is against the recommendation of RFC2047,\n    // by default only words that include non-ascii should be converted into encoded words\n    // but some clients (eg. Zimbra) do not handle it properly and remove surrounding whitespace\n    return mimeFuncs.encodeWords(value, this._getTextEncoding(value), 52, true);\n  }\n\n  /**\n   * Detects best mime encoding for a text value\n   *\n   * @param {String} value Value to check for\n   * @return {String} either 'Q' or 'B'\n   */\n  _getTextEncoding(value) {\n    value = (value || '').toString();\n    let encoding = this.textEncoding;\n    let latinLen;\n    let nonLatinLen;\n    if (!encoding) {\n      // count latin alphabet symbols and 8-bit range symbols + control symbols\n      // if there are more latin characters, then use quoted-printable\n      // encoding, otherwise use base64\n      nonLatinLen = (value.match(/[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\u0080-\\uFFFF]/g) || []).length; // eslint-disable-line no-control-regex\n      latinLen = (value.match(/[a-z]/gi) || []).length;\n      // if there are more latin symbols than binary/unicode, then prefer Q, otherwise B\n      encoding = nonLatinLen < latinLen ? 'Q' : 'B';\n    }\n    return encoding;\n  }\n\n  /**\n   * Generates a message id\n   *\n   * @return {String} Random Message-ID value\n   */\n  _generateMessageId() {\n    return '<' + [2, 2, 2, 6].reduce(\n    // crux to generate UUID-like random strings\n    (prev, len) => prev + '-' + crypto.randomBytes(len).toString('hex'), crypto.randomBytes(4).toString('hex')) + '@' +\n    // try to use the domain of the FROM address or fallback to server hostname\n    (this.getEnvelope().from || this.hostname || 'localhost').split('@').pop() + '>';\n  }\n}\nmodule.exports = MimeNode;","map":{"version":3,"names":["crypto","require","fs","punycode","PassThrough","shared","mimeFuncs","qp","base64","addressparser","nmfetch","LastNewline","LeWindows","LeUnix","MimeNode","constructor","contentType","options","nodeCounter","baseBoundary","randomBytes","toString","boundaryPrefix","disableFileAccess","disableUrlAccess","normalizeHeaderKey","date","Date","rootNode","keepBcc","filename","detectMimeType","split","pop","textEncoding","trim","charAt","toUpperCase","parentNode","hostname","newline","childNodes","_nodeId","_headers","_isPlainText","_hasLongLines","_envelope","_raw","_transforms","_processFuncs","setHeader","createChild","undefined","node","appendChild","childNode","push","replace","forEach","i","remove","length","splice","key","value","added","headerValue","Array","isArray","Object","keys","_normalizeHeaderKey","len","addHeader","val","getHeader","setContent","content","pipe","_contentErrorHandler","err","removeListener","once","isPlainText","hasLongerLines","build","callback","promise","Promise","resolve","reject","callbackPromise","stream","createReadStream","buf","buflen","returned","on","chunk","read","Buffer","concat","getTransferEncoding","transferEncoding","toLowerCase","includes","test","_getTextEncoding","buildHeaders","headers","toUTCString","messageId","header","structured","param","formattedHeaders","prepared","foldLines","parseHeaderValue","params","buildHeaderValue","_handleContentType","match","charset","_encodeWords","_encodeHeaderValue","normalized","join","outputStream","transform","emit","end","winbreak","newlineTransform","processFunc","done","contentStream","localStream","finalize","childId","processChildNode","write","boundary","child","setImmediate","multipart","sendContent","prototype","call","createStream","Encoder","_getStream","_resolve","chunks","chunklen","sourceStream","_resolvedValue","raw","setEnvelope","envelope","list","from","to","_convertAddresses","_parseAddresses","filter","address","map","standardFields","getAddresses","addresses","getEnvelope","_generateMessageId","setRaw","path","href","Error","httpHeaders","apply","_normalizeAddress","name","c","substr","indexOf","_generateBoundary","elm","str","uniqueList","values","_encodeAddressName","a","group","groupListAddresses","lastAt","lastIndexOf","user","domain","encodedDomain","toASCII","encodeWord","encodeWords","encoding","latinLen","nonLatinLen","reduce","prev","module","exports"],"sources":["C:/Users/deiby/Desktop/cloneWebCursos/paginacursos/node_modules/nodemailer/lib/mime-node/index.js"],"sourcesContent":["/* eslint no-undefined: 0, prefer-spread: 0, no-control-regex: 0 */\n\n'use strict';\n\nconst crypto = require('crypto');\nconst fs = require('fs');\nconst punycode = require('punycode');\nconst PassThrough = require('stream').PassThrough;\nconst shared = require('../shared');\n\nconst mimeFuncs = require('../mime-funcs');\nconst qp = require('../qp');\nconst base64 = require('../base64');\nconst addressparser = require('../addressparser');\nconst nmfetch = require('../fetch');\nconst LastNewline = require('./last-newline');\n\nconst LeWindows = require('./le-windows');\nconst LeUnix = require('./le-unix');\n\n/**\n * Creates a new mime tree node. Assumes 'multipart/*' as the content type\n * if it is a branch, anything else counts as leaf. If rootNode is missing from\n * the options, assumes this is the root.\n *\n * @param {String} contentType Define the content type for the node. Can be left blank for attachments (derived from filename)\n * @param {Object} [options] optional options\n * @param {Object} [options.rootNode] root node for this tree\n * @param {Object} [options.parentNode] immediate parent for this node\n * @param {Object} [options.filename] filename for an attachment node\n * @param {String} [options.baseBoundary] shared part of the unique multipart boundary\n * @param {Boolean} [options.keepBcc] If true, do not exclude Bcc from the generated headers\n * @param {Function} [options.normalizeHeaderKey] method to normalize header keys for custom caseing\n * @param {String} [options.textEncoding] either 'Q' (the default) or 'B'\n */\nclass MimeNode {\n    constructor(contentType, options) {\n        this.nodeCounter = 0;\n\n        options = options || {};\n\n        /**\n         * shared part of the unique multipart boundary\n         */\n        this.baseBoundary = options.baseBoundary || crypto.randomBytes(8).toString('hex');\n        this.boundaryPrefix = options.boundaryPrefix || '--_NmP';\n\n        this.disableFileAccess = !!options.disableFileAccess;\n        this.disableUrlAccess = !!options.disableUrlAccess;\n\n        this.normalizeHeaderKey = options.normalizeHeaderKey;\n\n        /**\n         * If date headers is missing and current node is the root, this value is used instead\n         */\n        this.date = new Date();\n\n        /**\n         * Root node for current mime tree\n         */\n        this.rootNode = options.rootNode || this;\n\n        /**\n         * If true include Bcc in generated headers (if available)\n         */\n        this.keepBcc = !!options.keepBcc;\n\n        /**\n         * If filename is specified but contentType is not (probably an attachment)\n         * detect the content type from filename extension\n         */\n        if (options.filename) {\n            /**\n             * Filename for this node. Useful with attachments\n             */\n            this.filename = options.filename;\n            if (!contentType) {\n                contentType = mimeFuncs.detectMimeType(this.filename.split('.').pop());\n            }\n        }\n\n        /**\n         * Indicates which encoding should be used for header strings: \"Q\" or \"B\"\n         */\n        this.textEncoding = (options.textEncoding || '').toString().trim().charAt(0).toUpperCase();\n\n        /**\n         * Immediate parent for this node (or undefined if not set)\n         */\n        this.parentNode = options.parentNode;\n\n        /**\n         * Hostname for default message-id values\n         */\n        this.hostname = options.hostname;\n\n        /**\n         * If set to 'win' then uses \\r\\n, if 'linux' then \\n. If not set (or `raw` is used) then newlines are kept as is.\n         */\n        this.newline = options.newline;\n\n        /**\n         * An array for possible child nodes\n         */\n        this.childNodes = [];\n\n        /**\n         * Used for generating unique boundaries (prepended to the shared base)\n         */\n        this._nodeId = ++this.rootNode.nodeCounter;\n\n        /**\n         * A list of header values for this node in the form of [{key:'', value:''}]\n         */\n        this._headers = [];\n\n        /**\n         * True if the content only uses ASCII printable characters\n         * @type {Boolean}\n         */\n        this._isPlainText = false;\n\n        /**\n         * True if the content is plain text but has longer lines than allowed\n         * @type {Boolean}\n         */\n        this._hasLongLines = false;\n\n        /**\n         * If set, use instead this value for envelopes instead of generating one\n         * @type {Boolean}\n         */\n        this._envelope = false;\n\n        /**\n         * If set then use this value as the stream content instead of building it\n         * @type {String|Buffer|Stream}\n         */\n        this._raw = false;\n\n        /**\n         * Additional transform streams that the message will be piped before\n         * exposing by createReadStream\n         * @type {Array}\n         */\n        this._transforms = [];\n\n        /**\n         * Additional process functions that the message will be piped through before\n         * exposing by createReadStream. These functions are run after transforms\n         * @type {Array}\n         */\n        this._processFuncs = [];\n\n        /**\n         * If content type is set (or derived from the filename) add it to headers\n         */\n        if (contentType) {\n            this.setHeader('Content-Type', contentType);\n        }\n    }\n\n    /////// PUBLIC METHODS\n\n    /**\n     * Creates and appends a child node.Arguments provided are passed to MimeNode constructor\n     *\n     * @param {String} [contentType] Optional content type\n     * @param {Object} [options] Optional options object\n     * @return {Object} Created node object\n     */\n    createChild(contentType, options) {\n        if (!options && typeof contentType === 'object') {\n            options = contentType;\n            contentType = undefined;\n        }\n        let node = new MimeNode(contentType, options);\n        this.appendChild(node);\n        return node;\n    }\n\n    /**\n     * Appends an existing node to the mime tree. Removes the node from an existing\n     * tree if needed\n     *\n     * @param {Object} childNode node to be appended\n     * @return {Object} Appended node object\n     */\n    appendChild(childNode) {\n        if (childNode.rootNode !== this.rootNode) {\n            childNode.rootNode = this.rootNode;\n            childNode._nodeId = ++this.rootNode.nodeCounter;\n        }\n\n        childNode.parentNode = this;\n\n        this.childNodes.push(childNode);\n        return childNode;\n    }\n\n    /**\n     * Replaces current node with another node\n     *\n     * @param {Object} node Replacement node\n     * @return {Object} Replacement node\n     */\n    replace(node) {\n        if (node === this) {\n            return this;\n        }\n\n        this.parentNode.childNodes.forEach((childNode, i) => {\n            if (childNode === this) {\n                node.rootNode = this.rootNode;\n                node.parentNode = this.parentNode;\n                node._nodeId = this._nodeId;\n\n                this.rootNode = this;\n                this.parentNode = undefined;\n\n                node.parentNode.childNodes[i] = node;\n            }\n        });\n\n        return node;\n    }\n\n    /**\n     * Removes current node from the mime tree\n     *\n     * @return {Object} removed node\n     */\n    remove() {\n        if (!this.parentNode) {\n            return this;\n        }\n\n        for (let i = this.parentNode.childNodes.length - 1; i >= 0; i--) {\n            if (this.parentNode.childNodes[i] === this) {\n                this.parentNode.childNodes.splice(i, 1);\n                this.parentNode = undefined;\n                this.rootNode = this;\n                return this;\n            }\n        }\n    }\n\n    /**\n     * Sets a header value. If the value for selected key exists, it is overwritten.\n     * You can set multiple values as well by using [{key:'', value:''}] or\n     * {key: 'value'} as the first argument.\n     *\n     * @param {String|Array|Object} key Header key or a list of key value pairs\n     * @param {String} value Header value\n     * @return {Object} current node\n     */\n    setHeader(key, value) {\n        let added = false,\n            headerValue;\n\n        // Allow setting multiple headers at once\n        if (!value && key && typeof key === 'object') {\n            // allow {key:'content-type', value: 'text/plain'}\n            if (key.key && 'value' in key) {\n                this.setHeader(key.key, key.value);\n            } else if (Array.isArray(key)) {\n                // allow [{key:'content-type', value: 'text/plain'}]\n                key.forEach(i => {\n                    this.setHeader(i.key, i.value);\n                });\n            } else {\n                // allow {'content-type': 'text/plain'}\n                Object.keys(key).forEach(i => {\n                    this.setHeader(i, key[i]);\n                });\n            }\n            return this;\n        }\n\n        key = this._normalizeHeaderKey(key);\n\n        headerValue = {\n            key,\n            value\n        };\n\n        // Check if the value exists and overwrite\n        for (let i = 0, len = this._headers.length; i < len; i++) {\n            if (this._headers[i].key === key) {\n                if (!added) {\n                    // replace the first match\n                    this._headers[i] = headerValue;\n                    added = true;\n                } else {\n                    // remove following matches\n                    this._headers.splice(i, 1);\n                    i--;\n                    len--;\n                }\n            }\n        }\n\n        // match not found, append the value\n        if (!added) {\n            this._headers.push(headerValue);\n        }\n\n        return this;\n    }\n\n    /**\n     * Adds a header value. If the value for selected key exists, the value is appended\n     * as a new field and old one is not touched.\n     * You can set multiple values as well by using [{key:'', value:''}] or\n     * {key: 'value'} as the first argument.\n     *\n     * @param {String|Array|Object} key Header key or a list of key value pairs\n     * @param {String} value Header value\n     * @return {Object} current node\n     */\n    addHeader(key, value) {\n        // Allow setting multiple headers at once\n        if (!value && key && typeof key === 'object') {\n            // allow {key:'content-type', value: 'text/plain'}\n            if (key.key && key.value) {\n                this.addHeader(key.key, key.value);\n            } else if (Array.isArray(key)) {\n                // allow [{key:'content-type', value: 'text/plain'}]\n                key.forEach(i => {\n                    this.addHeader(i.key, i.value);\n                });\n            } else {\n                // allow {'content-type': 'text/plain'}\n                Object.keys(key).forEach(i => {\n                    this.addHeader(i, key[i]);\n                });\n            }\n            return this;\n        } else if (Array.isArray(value)) {\n            value.forEach(val => {\n                this.addHeader(key, val);\n            });\n            return this;\n        }\n\n        this._headers.push({\n            key: this._normalizeHeaderKey(key),\n            value\n        });\n\n        return this;\n    }\n\n    /**\n     * Retrieves the first mathcing value of a selected key\n     *\n     * @param {String} key Key to search for\n     * @retun {String} Value for the key\n     */\n    getHeader(key) {\n        key = this._normalizeHeaderKey(key);\n        for (let i = 0, len = this._headers.length; i < len; i++) {\n            if (this._headers[i].key === key) {\n                return this._headers[i].value;\n            }\n        }\n    }\n\n    /**\n     * Sets body content for current node. If the value is a string, charset is added automatically\n     * to Content-Type (if it is text/*). If the value is a Buffer, you need to specify\n     * the charset yourself\n     *\n     * @param (String|Buffer) content Body content\n     * @return {Object} current node\n     */\n    setContent(content) {\n        this.content = content;\n        if (typeof this.content.pipe === 'function') {\n            // pre-stream handler. might be triggered if a stream is set as content\n            // and 'error' fires before anything is done with this stream\n            this._contentErrorHandler = err => {\n                this.content.removeListener('error', this._contentErrorHandler);\n                this.content = err;\n            };\n            this.content.once('error', this._contentErrorHandler);\n        } else if (typeof this.content === 'string') {\n            this._isPlainText = mimeFuncs.isPlainText(this.content);\n            if (this._isPlainText && mimeFuncs.hasLongerLines(this.content, 76)) {\n                // If there are lines longer than 76 symbols/bytes do not use 7bit\n                this._hasLongLines = true;\n            }\n        }\n        return this;\n    }\n\n    build(callback) {\n        let promise;\n\n        if (!callback) {\n            promise = new Promise((resolve, reject) => {\n                callback = shared.callbackPromise(resolve, reject);\n            });\n        }\n\n        let stream = this.createReadStream();\n        let buf = [];\n        let buflen = 0;\n        let returned = false;\n\n        stream.on('readable', () => {\n            let chunk;\n\n            while ((chunk = stream.read()) !== null) {\n                buf.push(chunk);\n                buflen += chunk.length;\n            }\n        });\n\n        stream.once('error', err => {\n            if (returned) {\n                return;\n            }\n            returned = true;\n\n            return callback(err);\n        });\n\n        stream.once('end', chunk => {\n            if (returned) {\n                return;\n            }\n            returned = true;\n\n            if (chunk && chunk.length) {\n                buf.push(chunk);\n                buflen += chunk.length;\n            }\n            return callback(null, Buffer.concat(buf, buflen));\n        });\n\n        return promise;\n    }\n\n    getTransferEncoding() {\n        let transferEncoding = false;\n        let contentType = (this.getHeader('Content-Type') || '').toString().toLowerCase().trim();\n\n        if (this.content) {\n            transferEncoding = (this.getHeader('Content-Transfer-Encoding') || '').toString().toLowerCase().trim();\n            if (!transferEncoding || !['base64', 'quoted-printable'].includes(transferEncoding)) {\n                if (/^text\\//i.test(contentType)) {\n                    // If there are no special symbols, no need to modify the text\n                    if (this._isPlainText && !this._hasLongLines) {\n                        transferEncoding = '7bit';\n                    } else if (typeof this.content === 'string' || this.content instanceof Buffer) {\n                        // detect preferred encoding for string value\n                        transferEncoding = this._getTextEncoding(this.content) === 'Q' ? 'quoted-printable' : 'base64';\n                    } else {\n                        // we can not check content for a stream, so either use preferred encoding or fallback to QP\n                        transferEncoding = this.textEncoding === 'B' ? 'base64' : 'quoted-printable';\n                    }\n                } else if (!/^(multipart|message)\\//i.test(contentType)) {\n                    transferEncoding = transferEncoding || 'base64';\n                }\n            }\n        }\n        return transferEncoding;\n    }\n\n    /**\n     * Builds the header block for the mime node. Append \\r\\n\\r\\n before writing the content\n     *\n     * @returns {String} Headers\n     */\n    buildHeaders() {\n        let transferEncoding = this.getTransferEncoding();\n        let headers = [];\n\n        if (transferEncoding) {\n            this.setHeader('Content-Transfer-Encoding', transferEncoding);\n        }\n\n        if (this.filename && !this.getHeader('Content-Disposition')) {\n            this.setHeader('Content-Disposition', 'attachment');\n        }\n\n        // Ensure mandatory header fields\n        if (this.rootNode === this) {\n            if (!this.getHeader('Date')) {\n                this.setHeader('Date', this.date.toUTCString().replace(/GMT/, '+0000'));\n            }\n\n            // ensure that Message-Id is present\n            this.messageId();\n\n            if (!this.getHeader('MIME-Version')) {\n                this.setHeader('MIME-Version', '1.0');\n            }\n        }\n\n        this._headers.forEach(header => {\n            let key = header.key;\n            let value = header.value;\n            let structured;\n            let param;\n            let options = {};\n            let formattedHeaders = ['From', 'Sender', 'To', 'Cc', 'Bcc', 'Reply-To', 'Date', 'References'];\n\n            if (value && typeof value === 'object' && !formattedHeaders.includes(key)) {\n                Object.keys(value).forEach(key => {\n                    if (key !== 'value') {\n                        options[key] = value[key];\n                    }\n                });\n                value = (value.value || '').toString();\n                if (!value.trim()) {\n                    return;\n                }\n            }\n\n            if (options.prepared) {\n                // header value is\n                if (options.foldLines) {\n                    headers.push(mimeFuncs.foldLines(key + ': ' + value));\n                } else {\n                    headers.push(key + ': ' + value);\n                }\n                return;\n            }\n\n            switch (header.key) {\n                case 'Content-Disposition':\n                    structured = mimeFuncs.parseHeaderValue(value);\n                    if (this.filename) {\n                        structured.params.filename = this.filename;\n                    }\n                    value = mimeFuncs.buildHeaderValue(structured);\n                    break;\n\n                case 'Content-Type':\n                    structured = mimeFuncs.parseHeaderValue(value);\n\n                    this._handleContentType(structured);\n\n                    if (structured.value.match(/^text\\/plain\\b/) && typeof this.content === 'string' && /[\\u0080-\\uFFFF]/.test(this.content)) {\n                        structured.params.charset = 'utf-8';\n                    }\n\n                    value = mimeFuncs.buildHeaderValue(structured);\n\n                    if (this.filename) {\n                        // add support for non-compliant clients like QQ webmail\n                        // we can't build the value with buildHeaderValue as the value is non standard and\n                        // would be converted to parameter continuation encoding that we do not want\n                        param = this._encodeWords(this.filename);\n\n                        if (param !== this.filename || /[\\s'\"\\\\;:/=(),<>@[\\]?]|^-/.test(param)) {\n                            // include value in quotes if needed\n                            param = '\"' + param + '\"';\n                        }\n                        value += '; name=' + param;\n                    }\n                    break;\n\n                case 'Bcc':\n                    if (!this.keepBcc) {\n                        // skip BCC values\n                        return;\n                    }\n                    break;\n            }\n\n            value = this._encodeHeaderValue(key, value);\n\n            // skip empty lines\n            if (!(value || '').toString().trim()) {\n                return;\n            }\n\n            if (typeof this.normalizeHeaderKey === 'function') {\n                let normalized = this.normalizeHeaderKey(key, value);\n                if (normalized && typeof normalized === 'string' && normalized.length) {\n                    key = normalized;\n                }\n            }\n\n            headers.push(mimeFuncs.foldLines(key + ': ' + value, 76));\n        });\n\n        return headers.join('\\r\\n');\n    }\n\n    /**\n     * Streams the rfc2822 message from the current node. If this is a root node,\n     * mandatory header fields are set if missing (Date, Message-Id, MIME-Version)\n     *\n     * @return {String} Compiled message\n     */\n    createReadStream(options) {\n        options = options || {};\n\n        let stream = new PassThrough(options);\n        let outputStream = stream;\n        let transform;\n\n        this.stream(stream, options, err => {\n            if (err) {\n                outputStream.emit('error', err);\n                return;\n            }\n            stream.end();\n        });\n\n        for (let i = 0, len = this._transforms.length; i < len; i++) {\n            transform = typeof this._transforms[i] === 'function' ? this._transforms[i]() : this._transforms[i];\n            outputStream.once('error', err => {\n                transform.emit('error', err);\n            });\n            outputStream = outputStream.pipe(transform);\n        }\n\n        // ensure terminating newline after possible user transforms\n        transform = new LastNewline();\n        outputStream.once('error', err => {\n            transform.emit('error', err);\n        });\n        outputStream = outputStream.pipe(transform);\n\n        // dkim and stuff\n        for (let i = 0, len = this._processFuncs.length; i < len; i++) {\n            transform = this._processFuncs[i];\n            outputStream = transform(outputStream);\n        }\n\n        if (this.newline) {\n            const winbreak = ['win', 'windows', 'dos', '\\r\\n'].includes(this.newline.toString().toLowerCase());\n            const newlineTransform = winbreak ? new LeWindows() : new LeUnix();\n\n            const stream = outputStream.pipe(newlineTransform);\n            outputStream.on('error', err => stream.emit('error', err));\n            return stream;\n        }\n\n        return outputStream;\n    }\n\n    /**\n     * Appends a transform stream object to the transforms list. Final output\n     * is passed through this stream before exposing\n     *\n     * @param {Object} transform Read-Write stream\n     */\n    transform(transform) {\n        this._transforms.push(transform);\n    }\n\n    /**\n     * Appends a post process function. The functon is run after transforms and\n     * uses the following syntax\n     *\n     *   processFunc(input) -> outputStream\n     *\n     * @param {Object} processFunc Read-Write stream\n     */\n    processFunc(processFunc) {\n        this._processFuncs.push(processFunc);\n    }\n\n    stream(outputStream, options, done) {\n        let transferEncoding = this.getTransferEncoding();\n        let contentStream;\n        let localStream;\n\n        // protect actual callback against multiple triggering\n        let returned = false;\n        let callback = err => {\n            if (returned) {\n                return;\n            }\n            returned = true;\n            done(err);\n        };\n\n        // for multipart nodes, push child nodes\n        // for content nodes end the stream\n        let finalize = () => {\n            let childId = 0;\n            let processChildNode = () => {\n                if (childId >= this.childNodes.length) {\n                    outputStream.write('\\r\\n--' + this.boundary + '--\\r\\n');\n                    return callback();\n                }\n                let child = this.childNodes[childId++];\n                outputStream.write((childId > 1 ? '\\r\\n' : '') + '--' + this.boundary + '\\r\\n');\n                child.stream(outputStream, options, err => {\n                    if (err) {\n                        return callback(err);\n                    }\n                    setImmediate(processChildNode);\n                });\n            };\n\n            if (this.multipart) {\n                setImmediate(processChildNode);\n            } else {\n                return callback();\n            }\n        };\n\n        // pushes node content\n        let sendContent = () => {\n            if (this.content) {\n                if (Object.prototype.toString.call(this.content) === '[object Error]') {\n                    // content is already errored\n                    return callback(this.content);\n                }\n\n                if (typeof this.content.pipe === 'function') {\n                    this.content.removeListener('error', this._contentErrorHandler);\n                    this._contentErrorHandler = err => callback(err);\n                    this.content.once('error', this._contentErrorHandler);\n                }\n\n                let createStream = () => {\n                    if (['quoted-printable', 'base64'].includes(transferEncoding)) {\n                        contentStream = new (transferEncoding === 'base64' ? base64 : qp).Encoder(options);\n\n                        contentStream.pipe(outputStream, {\n                            end: false\n                        });\n                        contentStream.once('end', finalize);\n                        contentStream.once('error', err => callback(err));\n\n                        localStream = this._getStream(this.content);\n                        localStream.pipe(contentStream);\n                    } else {\n                        // anything that is not QP or Base54 passes as-is\n                        localStream = this._getStream(this.content);\n                        localStream.pipe(outputStream, {\n                            end: false\n                        });\n                        localStream.once('end', finalize);\n                    }\n\n                    localStream.once('error', err => callback(err));\n                };\n\n                if (this.content._resolve) {\n                    let chunks = [];\n                    let chunklen = 0;\n                    let returned = false;\n                    let sourceStream = this._getStream(this.content);\n                    sourceStream.on('error', err => {\n                        if (returned) {\n                            return;\n                        }\n                        returned = true;\n                        callback(err);\n                    });\n                    sourceStream.on('readable', () => {\n                        let chunk;\n                        while ((chunk = sourceStream.read()) !== null) {\n                            chunks.push(chunk);\n                            chunklen += chunk.length;\n                        }\n                    });\n                    sourceStream.on('end', () => {\n                        if (returned) {\n                            return;\n                        }\n                        returned = true;\n                        this.content._resolve = false;\n                        this.content._resolvedValue = Buffer.concat(chunks, chunklen);\n                        setImmediate(createStream);\n                    });\n                } else {\n                    setImmediate(createStream);\n                }\n                return;\n            } else {\n                return setImmediate(finalize);\n            }\n        };\n\n        if (this._raw) {\n            setImmediate(() => {\n                if (Object.prototype.toString.call(this._raw) === '[object Error]') {\n                    // content is already errored\n                    return callback(this._raw);\n                }\n\n                // remove default error handler (if set)\n                if (typeof this._raw.pipe === 'function') {\n                    this._raw.removeListener('error', this._contentErrorHandler);\n                }\n\n                let raw = this._getStream(this._raw);\n                raw.pipe(outputStream, {\n                    end: false\n                });\n                raw.on('error', err => outputStream.emit('error', err));\n                raw.on('end', finalize);\n            });\n        } else {\n            outputStream.write(this.buildHeaders() + '\\r\\n\\r\\n');\n            setImmediate(sendContent);\n        }\n    }\n\n    /**\n     * Sets envelope to be used instead of the generated one\n     *\n     * @return {Object} SMTP envelope in the form of {from: 'from@example.com', to: ['to@example.com']}\n     */\n    setEnvelope(envelope) {\n        let list;\n\n        this._envelope = {\n            from: false,\n            to: []\n        };\n\n        if (envelope.from) {\n            list = [];\n            this._convertAddresses(this._parseAddresses(envelope.from), list);\n            list = list.filter(address => address && address.address);\n            if (list.length && list[0]) {\n                this._envelope.from = list[0].address;\n            }\n        }\n        ['to', 'cc', 'bcc'].forEach(key => {\n            if (envelope[key]) {\n                this._convertAddresses(this._parseAddresses(envelope[key]), this._envelope.to);\n            }\n        });\n\n        this._envelope.to = this._envelope.to.map(to => to.address).filter(address => address);\n\n        let standardFields = ['to', 'cc', 'bcc', 'from'];\n        Object.keys(envelope).forEach(key => {\n            if (!standardFields.includes(key)) {\n                this._envelope[key] = envelope[key];\n            }\n        });\n\n        return this;\n    }\n\n    /**\n     * Generates and returns an object with parsed address fields\n     *\n     * @return {Object} Address object\n     */\n    getAddresses() {\n        let addresses = {};\n\n        this._headers.forEach(header => {\n            let key = header.key.toLowerCase();\n            if (['from', 'sender', 'reply-to', 'to', 'cc', 'bcc'].includes(key)) {\n                if (!Array.isArray(addresses[key])) {\n                    addresses[key] = [];\n                }\n\n                this._convertAddresses(this._parseAddresses(header.value), addresses[key]);\n            }\n        });\n\n        return addresses;\n    }\n\n    /**\n     * Generates and returns SMTP envelope with the sender address and a list of recipients addresses\n     *\n     * @return {Object} SMTP envelope in the form of {from: 'from@example.com', to: ['to@example.com']}\n     */\n    getEnvelope() {\n        if (this._envelope) {\n            return this._envelope;\n        }\n\n        let envelope = {\n            from: false,\n            to: []\n        };\n        this._headers.forEach(header => {\n            let list = [];\n            if (header.key === 'From' || (!envelope.from && ['Reply-To', 'Sender'].includes(header.key))) {\n                this._convertAddresses(this._parseAddresses(header.value), list);\n                if (list.length && list[0]) {\n                    envelope.from = list[0].address;\n                }\n            } else if (['To', 'Cc', 'Bcc'].includes(header.key)) {\n                this._convertAddresses(this._parseAddresses(header.value), envelope.to);\n            }\n        });\n\n        envelope.to = envelope.to.map(to => to.address);\n\n        return envelope;\n    }\n\n    /**\n     * Returns Message-Id value. If it does not exist, then creates one\n     *\n     * @return {String} Message-Id value\n     */\n    messageId() {\n        let messageId = this.getHeader('Message-ID');\n        // You really should define your own Message-Id field!\n        if (!messageId) {\n            messageId = this._generateMessageId();\n            this.setHeader('Message-ID', messageId);\n        }\n        return messageId;\n    }\n\n    /**\n     * Sets pregenerated content that will be used as the output of this node\n     *\n     * @param {String|Buffer|Stream} Raw MIME contents\n     */\n    setRaw(raw) {\n        this._raw = raw;\n\n        if (this._raw && typeof this._raw.pipe === 'function') {\n            // pre-stream handler. might be triggered if a stream is set as content\n            // and 'error' fires before anything is done with this stream\n            this._contentErrorHandler = err => {\n                this._raw.removeListener('error', this._contentErrorHandler);\n                this._raw = err;\n            };\n            this._raw.once('error', this._contentErrorHandler);\n        }\n\n        return this;\n    }\n\n    /////// PRIVATE METHODS\n\n    /**\n     * Detects and returns handle to a stream related with the content.\n     *\n     * @param {Mixed} content Node content\n     * @returns {Object} Stream object\n     */\n    _getStream(content) {\n        let contentStream;\n\n        if (content._resolvedValue) {\n            // pass string or buffer content as a stream\n            contentStream = new PassThrough();\n            setImmediate(() => contentStream.end(content._resolvedValue));\n            return contentStream;\n        } else if (typeof content.pipe === 'function') {\n            // assume as stream\n            return content;\n        } else if (content && typeof content.path === 'string' && !content.href) {\n            if (this.disableFileAccess) {\n                contentStream = new PassThrough();\n                setImmediate(() => contentStream.emit('error', new Error('File access rejected for ' + content.path)));\n                return contentStream;\n            }\n            // read file\n            return fs.createReadStream(content.path);\n        } else if (content && typeof content.href === 'string') {\n            if (this.disableUrlAccess) {\n                contentStream = new PassThrough();\n                setImmediate(() => contentStream.emit('error', new Error('Url access rejected for ' + content.href)));\n                return contentStream;\n            }\n            // fetch URL\n            return nmfetch(content.href, { headers: content.httpHeaders });\n        } else {\n            // pass string or buffer content as a stream\n            contentStream = new PassThrough();\n            setImmediate(() => contentStream.end(content || ''));\n            return contentStream;\n        }\n    }\n\n    /**\n     * Parses addresses. Takes in a single address or an array or an\n     * array of address arrays (eg. To: [[first group], [second group],...])\n     *\n     * @param {Mixed} addresses Addresses to be parsed\n     * @return {Array} An array of address objects\n     */\n    _parseAddresses(addresses) {\n        return [].concat.apply(\n            [],\n            [].concat(addresses).map(address => {\n                // eslint-disable-line prefer-spread\n                if (address && address.address) {\n                    address.address = this._normalizeAddress(address.address);\n                    address.name = address.name || '';\n                    return [address];\n                }\n                return addressparser(address);\n            })\n        );\n    }\n\n    /**\n     * Normalizes a header key, uses Camel-Case form, except for uppercase MIME-\n     *\n     * @param {String} key Key to be normalized\n     * @return {String} key in Camel-Case form\n     */\n    _normalizeHeaderKey(key) {\n        key = (key || '')\n            .toString()\n            // no newlines in keys\n            .replace(/\\r?\\n|\\r/g, ' ')\n            .trim()\n            .toLowerCase()\n            // use uppercase words, except MIME\n            .replace(/^X-SMTPAPI$|^(MIME|DKIM|ARC|BIMI)\\b|^[a-z]|-(SPF|FBL|ID|MD5)$|-[a-z]/gi, c => c.toUpperCase())\n            // special case\n            .replace(/^Content-Features$/i, 'Content-features');\n\n        return key;\n    }\n\n    /**\n     * Checks if the content type is multipart and defines boundary if needed.\n     * Doesn't return anything, modifies object argument instead.\n     *\n     * @param {Object} structured Parsed header value for 'Content-Type' key\n     */\n    _handleContentType(structured) {\n        this.contentType = structured.value.trim().toLowerCase();\n\n        this.multipart = /^multipart\\//i.test(this.contentType) ? this.contentType.substr(this.contentType.indexOf('/') + 1) : false;\n\n        if (this.multipart) {\n            this.boundary = structured.params.boundary = structured.params.boundary || this.boundary || this._generateBoundary();\n        } else {\n            this.boundary = false;\n        }\n    }\n\n    /**\n     * Generates a multipart boundary value\n     *\n     * @return {String} boundary value\n     */\n    _generateBoundary() {\n        return this.rootNode.boundaryPrefix + '-' + this.rootNode.baseBoundary + '-Part_' + this._nodeId;\n    }\n\n    /**\n     * Encodes a header value for use in the generated rfc2822 email.\n     *\n     * @param {String} key Header key\n     * @param {String} value Header value\n     */\n    _encodeHeaderValue(key, value) {\n        key = this._normalizeHeaderKey(key);\n\n        switch (key) {\n            // Structured headers\n            case 'From':\n            case 'Sender':\n            case 'To':\n            case 'Cc':\n            case 'Bcc':\n            case 'Reply-To':\n                return this._convertAddresses(this._parseAddresses(value));\n\n            // values enclosed in <>\n            case 'Message-ID':\n            case 'In-Reply-To':\n            case 'Content-Id':\n                value = (value || '').toString().replace(/\\r?\\n|\\r/g, ' ');\n\n                if (value.charAt(0) !== '<') {\n                    value = '<' + value;\n                }\n\n                if (value.charAt(value.length - 1) !== '>') {\n                    value = value + '>';\n                }\n                return value;\n\n            // space separated list of values enclosed in <>\n            case 'References':\n                value = [].concat\n                    .apply(\n                        [],\n                        [].concat(value || '').map(elm => {\n                            // eslint-disable-line prefer-spread\n                            elm = (elm || '')\n                                .toString()\n                                .replace(/\\r?\\n|\\r/g, ' ')\n                                .trim();\n                            return elm.replace(/<[^>]*>/g, str => str.replace(/\\s/g, '')).split(/\\s+/);\n                        })\n                    )\n                    .map(elm => {\n                        if (elm.charAt(0) !== '<') {\n                            elm = '<' + elm;\n                        }\n                        if (elm.charAt(elm.length - 1) !== '>') {\n                            elm = elm + '>';\n                        }\n                        return elm;\n                    });\n\n                return value.join(' ').trim();\n\n            case 'Date':\n                if (Object.prototype.toString.call(value) === '[object Date]') {\n                    return value.toUTCString().replace(/GMT/, '+0000');\n                }\n\n                value = (value || '').toString().replace(/\\r?\\n|\\r/g, ' ');\n                return this._encodeWords(value);\n\n            case 'Content-Type':\n            case 'Content-Disposition':\n                // if it includes a filename then it is already encoded\n                return (value || '').toString().replace(/\\r?\\n|\\r/g, ' ');\n\n            default:\n                value = (value || '').toString().replace(/\\r?\\n|\\r/g, ' ');\n                // encodeWords only encodes if needed, otherwise the original string is returned\n                return this._encodeWords(value);\n        }\n    }\n\n    /**\n     * Rebuilds address object using punycode and other adjustments\n     *\n     * @param {Array} addresses An array of address objects\n     * @param {Array} [uniqueList] An array to be populated with addresses\n     * @return {String} address string\n     */\n    _convertAddresses(addresses, uniqueList) {\n        let values = [];\n\n        uniqueList = uniqueList || [];\n\n        [].concat(addresses || []).forEach(address => {\n            if (address.address) {\n                address.address = this._normalizeAddress(address.address);\n\n                if (!address.name) {\n                    values.push(address.address.indexOf(' ') >= 0 ? `<${address.address}>` : `${address.address}`);\n                } else if (address.name) {\n                    values.push(`${this._encodeAddressName(address.name)} <${address.address}>`);\n                }\n\n                if (address.address) {\n                    if (!uniqueList.filter(a => a.address === address.address).length) {\n                        uniqueList.push(address);\n                    }\n                }\n            } else if (address.group) {\n                let groupListAddresses = (address.group.length ? this._convertAddresses(address.group, uniqueList) : '').trim();\n                values.push(`${this._encodeAddressName(address.name)}:${groupListAddresses};`);\n            }\n        });\n\n        return values.join(', ');\n    }\n\n    /**\n     * Normalizes an email address\n     *\n     * @param {Array} address An array of address objects\n     * @return {String} address string\n     */\n    _normalizeAddress(address) {\n        address = (address || '')\n            .toString()\n            .replace(/[\\x00-\\x1F<>]+/g, ' ') // remove unallowed characters\n            .trim();\n\n        let lastAt = address.lastIndexOf('@');\n        if (lastAt < 0) {\n            // Bare username\n            return address;\n        }\n\n        let user = address.substr(0, lastAt);\n        let domain = address.substr(lastAt + 1);\n\n        // Usernames are not touched and are kept as is even if these include unicode\n        // Domains are punycoded by default\n        // 'jõgeva.ee' will be converted to 'xn--jgeva-dua.ee'\n        // non-unicode domains are left as is\n\n        let encodedDomain;\n\n        try {\n            encodedDomain = punycode.toASCII(domain.toLowerCase());\n        } catch (err) {\n            // keep as is?\n        }\n\n        if (user.indexOf(' ') >= 0) {\n            if (user.charAt(0) !== '\"') {\n                user = '\"' + user;\n            }\n            if (user.substr(-1) !== '\"') {\n                user = user + '\"';\n            }\n        }\n\n        return `${user}@${encodedDomain}`;\n    }\n\n    /**\n     * If needed, mime encodes the name part\n     *\n     * @param {String} name Name part of an address\n     * @returns {String} Mime word encoded string if needed\n     */\n    _encodeAddressName(name) {\n        if (!/^[\\w ']*$/.test(name)) {\n            if (/^[\\x20-\\x7e]*$/.test(name)) {\n                return '\"' + name.replace(/([\\\\\"])/g, '\\\\$1') + '\"';\n            } else {\n                return mimeFuncs.encodeWord(name, this._getTextEncoding(name), 52);\n            }\n        }\n        return name;\n    }\n\n    /**\n     * If needed, mime encodes the name part\n     *\n     * @param {String} name Name part of an address\n     * @returns {String} Mime word encoded string if needed\n     */\n    _encodeWords(value) {\n        // set encodeAll parameter to true even though it is against the recommendation of RFC2047,\n        // by default only words that include non-ascii should be converted into encoded words\n        // but some clients (eg. Zimbra) do not handle it properly and remove surrounding whitespace\n        return mimeFuncs.encodeWords(value, this._getTextEncoding(value), 52, true);\n    }\n\n    /**\n     * Detects best mime encoding for a text value\n     *\n     * @param {String} value Value to check for\n     * @return {String} either 'Q' or 'B'\n     */\n    _getTextEncoding(value) {\n        value = (value || '').toString();\n\n        let encoding = this.textEncoding;\n        let latinLen;\n        let nonLatinLen;\n\n        if (!encoding) {\n            // count latin alphabet symbols and 8-bit range symbols + control symbols\n            // if there are more latin characters, then use quoted-printable\n            // encoding, otherwise use base64\n            nonLatinLen = (value.match(/[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\u0080-\\uFFFF]/g) || []).length; // eslint-disable-line no-control-regex\n            latinLen = (value.match(/[a-z]/gi) || []).length;\n            // if there are more latin symbols than binary/unicode, then prefer Q, otherwise B\n            encoding = nonLatinLen < latinLen ? 'Q' : 'B';\n        }\n        return encoding;\n    }\n\n    /**\n     * Generates a message id\n     *\n     * @return {String} Random Message-ID value\n     */\n    _generateMessageId() {\n        return (\n            '<' +\n            [2, 2, 2, 6].reduce(\n                // crux to generate UUID-like random strings\n                (prev, len) => prev + '-' + crypto.randomBytes(len).toString('hex'),\n                crypto.randomBytes(4).toString('hex')\n            ) +\n            '@' +\n            // try to use the domain of the FROM address or fallback to server hostname\n            (this.getEnvelope().from || this.hostname || 'localhost').split('@').pop() +\n            '>'\n        );\n    }\n}\n\nmodule.exports = MimeNode;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}