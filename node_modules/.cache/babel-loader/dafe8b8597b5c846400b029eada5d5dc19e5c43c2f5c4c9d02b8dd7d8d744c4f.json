{"ast":null,"code":"'use strict';\n\n/**\n * Minimal HTTP/S proxy client\n */\nconst net = require('net');\nconst tls = require('tls');\nconst urllib = require('url');\n\n/**\n * Establishes proxied connection to destinationPort\n *\n * httpProxyClient(\"http://localhost:3128/\", 80, \"google.com\", function(err, socket){\n *     socket.write(\"GET / HTTP/1.0\\r\\n\\r\\n\");\n * });\n *\n * @param {String} proxyUrl proxy configuration, etg \"http://proxy.host:3128/\"\n * @param {Number} destinationPort Port to open in destination host\n * @param {String} destinationHost Destination hostname\n * @param {Function} callback Callback to run with the rocket object once connection is established\n */\nfunction httpProxyClient(proxyUrl, destinationPort, destinationHost, callback) {\n  let proxy = urllib.parse(proxyUrl);\n\n  // create a socket connection to the proxy server\n  let options;\n  let connect;\n  let socket;\n  options = {\n    host: proxy.hostname,\n    port: Number(proxy.port) ? Number(proxy.port) : proxy.protocol === 'https:' ? 443 : 80\n  };\n  if (proxy.protocol === 'https:') {\n    // we can use untrusted proxies as long as we verify actual SMTP certificates\n    options.rejectUnauthorized = false;\n    connect = tls.connect.bind(tls);\n  } else {\n    connect = net.connect.bind(net);\n  }\n\n  // Error harness for initial connection. Once connection is established, the responsibility\n  // to handle errors is passed to whoever uses this socket\n  let finished = false;\n  let tempSocketErr = err => {\n    if (finished) {\n      return;\n    }\n    finished = true;\n    try {\n      socket.destroy();\n    } catch (E) {\n      // ignore\n    }\n    callback(err);\n  };\n  let timeoutErr = () => {\n    let err = new Error('Proxy socket timed out');\n    err.code = 'ETIMEDOUT';\n    tempSocketErr(err);\n  };\n  socket = connect(options, () => {\n    if (finished) {\n      return;\n    }\n    let reqHeaders = {\n      Host: destinationHost + ':' + destinationPort,\n      Connection: 'close'\n    };\n    if (proxy.auth) {\n      reqHeaders['Proxy-Authorization'] = 'Basic ' + Buffer.from(proxy.auth).toString('base64');\n    }\n    socket.write(\n    // HTTP method\n    'CONNECT ' + destinationHost + ':' + destinationPort + ' HTTP/1.1\\r\\n' +\n    // HTTP request headers\n    Object.keys(reqHeaders).map(key => key + ': ' + reqHeaders[key]).join('\\r\\n') +\n    // End request\n    '\\r\\n\\r\\n');\n    let headers = '';\n    let onSocketData = chunk => {\n      let match;\n      let remainder;\n      if (finished) {\n        return;\n      }\n      headers += chunk.toString('binary');\n      if (match = headers.match(/\\r\\n\\r\\n/)) {\n        socket.removeListener('data', onSocketData);\n        remainder = headers.substr(match.index + match[0].length);\n        headers = headers.substr(0, match.index);\n        if (remainder) {\n          socket.unshift(Buffer.from(remainder, 'binary'));\n        }\n\n        // proxy connection is now established\n        finished = true;\n\n        // check response code\n        match = headers.match(/^HTTP\\/\\d+\\.\\d+ (\\d+)/i);\n        if (!match || (match[1] || '').charAt(0) !== '2') {\n          try {\n            socket.destroy();\n          } catch (E) {\n            // ignore\n          }\n          return callback(new Error('Invalid response from proxy' + (match && ': ' + match[1] || '')));\n        }\n        socket.removeListener('error', tempSocketErr);\n        socket.removeListener('timeout', timeoutErr);\n        socket.setTimeout(0);\n        return callback(null, socket);\n      }\n    };\n    socket.on('data', onSocketData);\n  });\n  socket.setTimeout(httpProxyClient.timeout || 30 * 1000);\n  socket.on('timeout', timeoutErr);\n  socket.once('error', tempSocketErr);\n}\nmodule.exports = httpProxyClient;","map":{"version":3,"names":["net","require","tls","urllib","httpProxyClient","proxyUrl","destinationPort","destinationHost","callback","proxy","parse","options","connect","socket","host","hostname","port","Number","protocol","rejectUnauthorized","bind","finished","tempSocketErr","err","destroy","E","timeoutErr","Error","code","reqHeaders","Host","Connection","auth","Buffer","from","toString","write","Object","keys","map","key","join","headers","onSocketData","chunk","match","remainder","removeListener","substr","index","length","unshift","charAt","setTimeout","on","timeout","once","module","exports"],"sources":["C:/Users/deiby/Desktop/cloneWebCursos/paginacursos/node_modules/nodemailer/lib/smtp-connection/http-proxy-client.js"],"sourcesContent":["'use strict';\n\n/**\n * Minimal HTTP/S proxy client\n */\n\nconst net = require('net');\nconst tls = require('tls');\nconst urllib = require('url');\n\n/**\n * Establishes proxied connection to destinationPort\n *\n * httpProxyClient(\"http://localhost:3128/\", 80, \"google.com\", function(err, socket){\n *     socket.write(\"GET / HTTP/1.0\\r\\n\\r\\n\");\n * });\n *\n * @param {String} proxyUrl proxy configuration, etg \"http://proxy.host:3128/\"\n * @param {Number} destinationPort Port to open in destination host\n * @param {String} destinationHost Destination hostname\n * @param {Function} callback Callback to run with the rocket object once connection is established\n */\nfunction httpProxyClient(proxyUrl, destinationPort, destinationHost, callback) {\n    let proxy = urllib.parse(proxyUrl);\n\n    // create a socket connection to the proxy server\n    let options;\n    let connect;\n    let socket;\n\n    options = {\n        host: proxy.hostname,\n        port: Number(proxy.port) ? Number(proxy.port) : proxy.protocol === 'https:' ? 443 : 80\n    };\n\n    if (proxy.protocol === 'https:') {\n        // we can use untrusted proxies as long as we verify actual SMTP certificates\n        options.rejectUnauthorized = false;\n        connect = tls.connect.bind(tls);\n    } else {\n        connect = net.connect.bind(net);\n    }\n\n    // Error harness for initial connection. Once connection is established, the responsibility\n    // to handle errors is passed to whoever uses this socket\n    let finished = false;\n    let tempSocketErr = err => {\n        if (finished) {\n            return;\n        }\n        finished = true;\n        try {\n            socket.destroy();\n        } catch (E) {\n            // ignore\n        }\n        callback(err);\n    };\n\n    let timeoutErr = () => {\n        let err = new Error('Proxy socket timed out');\n        err.code = 'ETIMEDOUT';\n        tempSocketErr(err);\n    };\n\n    socket = connect(options, () => {\n        if (finished) {\n            return;\n        }\n\n        let reqHeaders = {\n            Host: destinationHost + ':' + destinationPort,\n            Connection: 'close'\n        };\n        if (proxy.auth) {\n            reqHeaders['Proxy-Authorization'] = 'Basic ' + Buffer.from(proxy.auth).toString('base64');\n        }\n\n        socket.write(\n            // HTTP method\n            'CONNECT ' +\n                destinationHost +\n                ':' +\n                destinationPort +\n                ' HTTP/1.1\\r\\n' +\n                // HTTP request headers\n                Object.keys(reqHeaders)\n                    .map(key => key + ': ' + reqHeaders[key])\n                    .join('\\r\\n') +\n                // End request\n                '\\r\\n\\r\\n'\n        );\n\n        let headers = '';\n        let onSocketData = chunk => {\n            let match;\n            let remainder;\n\n            if (finished) {\n                return;\n            }\n\n            headers += chunk.toString('binary');\n            if ((match = headers.match(/\\r\\n\\r\\n/))) {\n                socket.removeListener('data', onSocketData);\n\n                remainder = headers.substr(match.index + match[0].length);\n                headers = headers.substr(0, match.index);\n                if (remainder) {\n                    socket.unshift(Buffer.from(remainder, 'binary'));\n                }\n\n                // proxy connection is now established\n                finished = true;\n\n                // check response code\n                match = headers.match(/^HTTP\\/\\d+\\.\\d+ (\\d+)/i);\n                if (!match || (match[1] || '').charAt(0) !== '2') {\n                    try {\n                        socket.destroy();\n                    } catch (E) {\n                        // ignore\n                    }\n                    return callback(new Error('Invalid response from proxy' + ((match && ': ' + match[1]) || '')));\n                }\n\n                socket.removeListener('error', tempSocketErr);\n                socket.removeListener('timeout', timeoutErr);\n                socket.setTimeout(0);\n\n                return callback(null, socket);\n            }\n        };\n        socket.on('data', onSocketData);\n    });\n\n    socket.setTimeout(httpProxyClient.timeout || 30 * 1000);\n    socket.on('timeout', timeoutErr);\n\n    socket.once('error', tempSocketErr);\n}\n\nmodule.exports = httpProxyClient;\n"],"mappings":"AAAA,YAAY;;AAEZ;AACA;AACA;AAEA,MAAMA,GAAG,GAAGC,OAAO,CAAC,KAAK,CAAC;AAC1B,MAAMC,GAAG,GAAGD,OAAO,CAAC,KAAK,CAAC;AAC1B,MAAME,MAAM,GAAGF,OAAO,CAAC,KAAK,CAAC;;AAE7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASG,eAAe,CAACC,QAAQ,EAAEC,eAAe,EAAEC,eAAe,EAAEC,QAAQ,EAAE;EAC3E,IAAIC,KAAK,GAAGN,MAAM,CAACO,KAAK,CAACL,QAAQ,CAAC;;EAElC;EACA,IAAIM,OAAO;EACX,IAAIC,OAAO;EACX,IAAIC,MAAM;EAEVF,OAAO,GAAG;IACNG,IAAI,EAAEL,KAAK,CAACM,QAAQ;IACpBC,IAAI,EAAEC,MAAM,CAACR,KAAK,CAACO,IAAI,CAAC,GAAGC,MAAM,CAACR,KAAK,CAACO,IAAI,CAAC,GAAGP,KAAK,CAACS,QAAQ,KAAK,QAAQ,GAAG,GAAG,GAAG;EACxF,CAAC;EAED,IAAIT,KAAK,CAACS,QAAQ,KAAK,QAAQ,EAAE;IAC7B;IACAP,OAAO,CAACQ,kBAAkB,GAAG,KAAK;IAClCP,OAAO,GAAGV,GAAG,CAACU,OAAO,CAACQ,IAAI,CAAClB,GAAG,CAAC;EACnC,CAAC,MAAM;IACHU,OAAO,GAAGZ,GAAG,CAACY,OAAO,CAACQ,IAAI,CAACpB,GAAG,CAAC;EACnC;;EAEA;EACA;EACA,IAAIqB,QAAQ,GAAG,KAAK;EACpB,IAAIC,aAAa,GAAGC,GAAG,IAAI;IACvB,IAAIF,QAAQ,EAAE;MACV;IACJ;IACAA,QAAQ,GAAG,IAAI;IACf,IAAI;MACAR,MAAM,CAACW,OAAO,EAAE;IACpB,CAAC,CAAC,OAAOC,CAAC,EAAE;MACR;IAAA;IAEJjB,QAAQ,CAACe,GAAG,CAAC;EACjB,CAAC;EAED,IAAIG,UAAU,GAAG,MAAM;IACnB,IAAIH,GAAG,GAAG,IAAII,KAAK,CAAC,wBAAwB,CAAC;IAC7CJ,GAAG,CAACK,IAAI,GAAG,WAAW;IACtBN,aAAa,CAACC,GAAG,CAAC;EACtB,CAAC;EAEDV,MAAM,GAAGD,OAAO,CAACD,OAAO,EAAE,MAAM;IAC5B,IAAIU,QAAQ,EAAE;MACV;IACJ;IAEA,IAAIQ,UAAU,GAAG;MACbC,IAAI,EAAEvB,eAAe,GAAG,GAAG,GAAGD,eAAe;MAC7CyB,UAAU,EAAE;IAChB,CAAC;IACD,IAAItB,KAAK,CAACuB,IAAI,EAAE;MACZH,UAAU,CAAC,qBAAqB,CAAC,GAAG,QAAQ,GAAGI,MAAM,CAACC,IAAI,CAACzB,KAAK,CAACuB,IAAI,CAAC,CAACG,QAAQ,CAAC,QAAQ,CAAC;IAC7F;IAEAtB,MAAM,CAACuB,KAAK;IACR;IACA,UAAU,GACN7B,eAAe,GACf,GAAG,GACHD,eAAe,GACf,eAAe;IACf;IACA+B,MAAM,CAACC,IAAI,CAACT,UAAU,CAAC,CAClBU,GAAG,CAACC,GAAG,IAAIA,GAAG,GAAG,IAAI,GAAGX,UAAU,CAACW,GAAG,CAAC,CAAC,CACxCC,IAAI,CAAC,MAAM,CAAC;IACjB;IACA,UAAU,CACjB;IAED,IAAIC,OAAO,GAAG,EAAE;IAChB,IAAIC,YAAY,GAAGC,KAAK,IAAI;MACxB,IAAIC,KAAK;MACT,IAAIC,SAAS;MAEb,IAAIzB,QAAQ,EAAE;QACV;MACJ;MAEAqB,OAAO,IAAIE,KAAK,CAACT,QAAQ,CAAC,QAAQ,CAAC;MACnC,IAAKU,KAAK,GAAGH,OAAO,CAACG,KAAK,CAAC,UAAU,CAAC,EAAG;QACrChC,MAAM,CAACkC,cAAc,CAAC,MAAM,EAAEJ,YAAY,CAAC;QAE3CG,SAAS,GAAGJ,OAAO,CAACM,MAAM,CAACH,KAAK,CAACI,KAAK,GAAGJ,KAAK,CAAC,CAAC,CAAC,CAACK,MAAM,CAAC;QACzDR,OAAO,GAAGA,OAAO,CAACM,MAAM,CAAC,CAAC,EAAEH,KAAK,CAACI,KAAK,CAAC;QACxC,IAAIH,SAAS,EAAE;UACXjC,MAAM,CAACsC,OAAO,CAAClB,MAAM,CAACC,IAAI,CAACY,SAAS,EAAE,QAAQ,CAAC,CAAC;QACpD;;QAEA;QACAzB,QAAQ,GAAG,IAAI;;QAEf;QACAwB,KAAK,GAAGH,OAAO,CAACG,KAAK,CAAC,wBAAwB,CAAC;QAC/C,IAAI,CAACA,KAAK,IAAI,CAACA,KAAK,CAAC,CAAC,CAAC,IAAI,EAAE,EAAEO,MAAM,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;UAC9C,IAAI;YACAvC,MAAM,CAACW,OAAO,EAAE;UACpB,CAAC,CAAC,OAAOC,CAAC,EAAE;YACR;UAAA;UAEJ,OAAOjB,QAAQ,CAAC,IAAImB,KAAK,CAAC,6BAA6B,IAAKkB,KAAK,IAAI,IAAI,GAAGA,KAAK,CAAC,CAAC,CAAC,IAAK,EAAE,CAAC,CAAC,CAAC;QAClG;QAEAhC,MAAM,CAACkC,cAAc,CAAC,OAAO,EAAEzB,aAAa,CAAC;QAC7CT,MAAM,CAACkC,cAAc,CAAC,SAAS,EAAErB,UAAU,CAAC;QAC5Cb,MAAM,CAACwC,UAAU,CAAC,CAAC,CAAC;QAEpB,OAAO7C,QAAQ,CAAC,IAAI,EAAEK,MAAM,CAAC;MACjC;IACJ,CAAC;IACDA,MAAM,CAACyC,EAAE,CAAC,MAAM,EAAEX,YAAY,CAAC;EACnC,CAAC,CAAC;EAEF9B,MAAM,CAACwC,UAAU,CAACjD,eAAe,CAACmD,OAAO,IAAI,EAAE,GAAG,IAAI,CAAC;EACvD1C,MAAM,CAACyC,EAAE,CAAC,SAAS,EAAE5B,UAAU,CAAC;EAEhCb,MAAM,CAAC2C,IAAI,CAAC,OAAO,EAAElC,aAAa,CAAC;AACvC;AAEAmC,MAAM,CAACC,OAAO,GAAGtD,eAAe"},"metadata":{},"sourceType":"script","externalDependencies":[]}