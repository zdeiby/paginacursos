{"ast":null,"code":"'use strict';\n\nconst Transform = require('stream').Transform;\n\n/**\n * Encodes a Buffer into a Quoted-Printable encoded string\n *\n * @param {Buffer} buffer Buffer to convert\n * @returns {String} Quoted-Printable encoded string\n */\nfunction encode(buffer) {\n  if (typeof buffer === 'string') {\n    buffer = Buffer.from(buffer, 'utf-8');\n  }\n\n  // usable characters that do not need encoding\n  let ranges = [\n  // https://tools.ietf.org/html/rfc2045#section-6.7\n  [0x09],\n  // <TAB>\n  [0x0a],\n  // <LF>\n  [0x0d],\n  // <CR>\n  [0x20, 0x3c],\n  // <SP>!\"#$%&'()*+,-./0123456789:;\n  [0x3e, 0x7e] // >?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}\n  ];\n\n  let result = '';\n  let ord;\n  for (let i = 0, len = buffer.length; i < len; i++) {\n    ord = buffer[i];\n    // if the char is in allowed range, then keep as is, unless it is a WS in the end of a line\n    if (checkRanges(ord, ranges) && !((ord === 0x20 || ord === 0x09) && (i === len - 1 || buffer[i + 1] === 0x0a || buffer[i + 1] === 0x0d))) {\n      result += String.fromCharCode(ord);\n      continue;\n    }\n    result += '=' + (ord < 0x10 ? '0' : '') + ord.toString(16).toUpperCase();\n  }\n  return result;\n}\n\n/**\n * Adds soft line breaks to a Quoted-Printable string\n *\n * @param {String} str Quoted-Printable encoded string that might need line wrapping\n * @param {Number} [lineLength=76] Maximum allowed length for a line\n * @returns {String} Soft-wrapped Quoted-Printable encoded string\n */\nfunction wrap(str, lineLength) {\n  str = (str || '').toString();\n  lineLength = lineLength || 76;\n  if (str.length <= lineLength) {\n    return str;\n  }\n  let pos = 0;\n  let len = str.length;\n  let match, code, line;\n  let lineMargin = Math.floor(lineLength / 3);\n  let result = '';\n\n  // insert soft linebreaks where needed\n  while (pos < len) {\n    line = str.substr(pos, lineLength);\n    if (match = line.match(/\\r\\n/)) {\n      line = line.substr(0, match.index + match[0].length);\n      result += line;\n      pos += line.length;\n      continue;\n    }\n    if (line.substr(-1) === '\\n') {\n      // nothing to change here\n      result += line;\n      pos += line.length;\n      continue;\n    } else if (match = line.substr(-lineMargin).match(/\\n.*?$/)) {\n      // truncate to nearest line break\n      line = line.substr(0, line.length - (match[0].length - 1));\n      result += line;\n      pos += line.length;\n      continue;\n    } else if (line.length > lineLength - lineMargin && (match = line.substr(-lineMargin).match(/[ \\t.,!?][^ \\t.,!?]*$/))) {\n      // truncate to nearest space\n      line = line.substr(0, line.length - (match[0].length - 1));\n    } else if (line.match(/[=][\\da-f]{0,2}$/i)) {\n      // push incomplete encoding sequences to the next line\n      if (match = line.match(/[=][\\da-f]{0,1}$/i)) {\n        line = line.substr(0, line.length - match[0].length);\n      }\n\n      // ensure that utf-8 sequences are not split\n      while (line.length > 3 && line.length < len - pos && !line.match(/^(?:=[\\da-f]{2}){1,4}$/i) && (match = line.match(/[=][\\da-f]{2}$/gi))) {\n        code = parseInt(match[0].substr(1, 2), 16);\n        if (code < 128) {\n          break;\n        }\n        line = line.substr(0, line.length - 3);\n        if (code >= 0xc0) {\n          break;\n        }\n      }\n    }\n    if (pos + line.length < len && line.substr(-1) !== '\\n') {\n      if (line.length === lineLength && line.match(/[=][\\da-f]{2}$/i)) {\n        line = line.substr(0, line.length - 3);\n      } else if (line.length === lineLength) {\n        line = line.substr(0, line.length - 1);\n      }\n      pos += line.length;\n      line += '=\\r\\n';\n    } else {\n      pos += line.length;\n    }\n    result += line;\n  }\n  return result;\n}\n\n/**\n * Helper function to check if a number is inside provided ranges\n *\n * @param {Number} nr Number to check for\n * @param {Array} ranges An Array of allowed values\n * @returns {Boolean} True if the value was found inside allowed ranges, false otherwise\n */\nfunction checkRanges(nr, ranges) {\n  for (let i = ranges.length - 1; i >= 0; i--) {\n    if (!ranges[i].length) {\n      continue;\n    }\n    if (ranges[i].length === 1 && nr === ranges[i][0]) {\n      return true;\n    }\n    if (ranges[i].length === 2 && nr >= ranges[i][0] && nr <= ranges[i][1]) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Creates a transform stream for encoding data to Quoted-Printable encoding\n *\n * @constructor\n * @param {Object} options Stream options\n * @param {Number} [options.lineLength=76] Maximum length for lines, set to false to disable wrapping\n */\nclass Encoder extends Transform {\n  constructor(options) {\n    super();\n\n    // init Transform\n    this.options = options || {};\n    if (this.options.lineLength !== false) {\n      this.options.lineLength = this.options.lineLength || 76;\n    }\n    this._curLine = '';\n    this.inputBytes = 0;\n    this.outputBytes = 0;\n  }\n  _transform(chunk, encoding, done) {\n    let qp;\n    if (encoding !== 'buffer') {\n      chunk = Buffer.from(chunk, encoding);\n    }\n    if (!chunk || !chunk.length) {\n      return done();\n    }\n    this.inputBytes += chunk.length;\n    if (this.options.lineLength) {\n      qp = this._curLine + encode(chunk);\n      qp = wrap(qp, this.options.lineLength);\n      qp = qp.replace(/(^|\\n)([^\\n]*)$/, (match, lineBreak, lastLine) => {\n        this._curLine = lastLine;\n        return lineBreak;\n      });\n      if (qp) {\n        this.outputBytes += qp.length;\n        this.push(qp);\n      }\n    } else {\n      qp = encode(chunk);\n      this.outputBytes += qp.length;\n      this.push(qp, 'ascii');\n    }\n    done();\n  }\n  _flush(done) {\n    if (this._curLine) {\n      this.outputBytes += this._curLine.length;\n      this.push(this._curLine, 'ascii');\n    }\n    done();\n  }\n}\n\n// expose to the world\nmodule.exports = {\n  encode,\n  wrap,\n  Encoder\n};","map":{"version":3,"names":["Transform","require","encode","buffer","Buffer","from","ranges","result","ord","i","len","length","checkRanges","String","fromCharCode","toString","toUpperCase","wrap","str","lineLength","pos","match","code","line","lineMargin","Math","floor","substr","index","parseInt","nr","Encoder","constructor","options","_curLine","inputBytes","outputBytes","_transform","chunk","encoding","done","qp","replace","lineBreak","lastLine","push","_flush","module","exports"],"sources":["C:/Users/deiby/Desktop/cloneWebCursos/paginacursos/node_modules/nodemailer/lib/qp/index.js"],"sourcesContent":["'use strict';\n\nconst Transform = require('stream').Transform;\n\n/**\n * Encodes a Buffer into a Quoted-Printable encoded string\n *\n * @param {Buffer} buffer Buffer to convert\n * @returns {String} Quoted-Printable encoded string\n */\nfunction encode(buffer) {\n    if (typeof buffer === 'string') {\n        buffer = Buffer.from(buffer, 'utf-8');\n    }\n\n    // usable characters that do not need encoding\n    let ranges = [\n        // https://tools.ietf.org/html/rfc2045#section-6.7\n        [0x09], // <TAB>\n        [0x0a], // <LF>\n        [0x0d], // <CR>\n        [0x20, 0x3c], // <SP>!\"#$%&'()*+,-./0123456789:;\n        [0x3e, 0x7e] // >?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}\n    ];\n    let result = '';\n    let ord;\n\n    for (let i = 0, len = buffer.length; i < len; i++) {\n        ord = buffer[i];\n        // if the char is in allowed range, then keep as is, unless it is a WS in the end of a line\n        if (checkRanges(ord, ranges) && !((ord === 0x20 || ord === 0x09) && (i === len - 1 || buffer[i + 1] === 0x0a || buffer[i + 1] === 0x0d))) {\n            result += String.fromCharCode(ord);\n            continue;\n        }\n        result += '=' + (ord < 0x10 ? '0' : '') + ord.toString(16).toUpperCase();\n    }\n\n    return result;\n}\n\n/**\n * Adds soft line breaks to a Quoted-Printable string\n *\n * @param {String} str Quoted-Printable encoded string that might need line wrapping\n * @param {Number} [lineLength=76] Maximum allowed length for a line\n * @returns {String} Soft-wrapped Quoted-Printable encoded string\n */\nfunction wrap(str, lineLength) {\n    str = (str || '').toString();\n    lineLength = lineLength || 76;\n\n    if (str.length <= lineLength) {\n        return str;\n    }\n\n    let pos = 0;\n    let len = str.length;\n    let match, code, line;\n    let lineMargin = Math.floor(lineLength / 3);\n    let result = '';\n\n    // insert soft linebreaks where needed\n    while (pos < len) {\n        line = str.substr(pos, lineLength);\n        if ((match = line.match(/\\r\\n/))) {\n            line = line.substr(0, match.index + match[0].length);\n            result += line;\n            pos += line.length;\n            continue;\n        }\n\n        if (line.substr(-1) === '\\n') {\n            // nothing to change here\n            result += line;\n            pos += line.length;\n            continue;\n        } else if ((match = line.substr(-lineMargin).match(/\\n.*?$/))) {\n            // truncate to nearest line break\n            line = line.substr(0, line.length - (match[0].length - 1));\n            result += line;\n            pos += line.length;\n            continue;\n        } else if (line.length > lineLength - lineMargin && (match = line.substr(-lineMargin).match(/[ \\t.,!?][^ \\t.,!?]*$/))) {\n            // truncate to nearest space\n            line = line.substr(0, line.length - (match[0].length - 1));\n        } else if (line.match(/[=][\\da-f]{0,2}$/i)) {\n            // push incomplete encoding sequences to the next line\n            if ((match = line.match(/[=][\\da-f]{0,1}$/i))) {\n                line = line.substr(0, line.length - match[0].length);\n            }\n\n            // ensure that utf-8 sequences are not split\n            while (line.length > 3 && line.length < len - pos && !line.match(/^(?:=[\\da-f]{2}){1,4}$/i) && (match = line.match(/[=][\\da-f]{2}$/gi))) {\n                code = parseInt(match[0].substr(1, 2), 16);\n                if (code < 128) {\n                    break;\n                }\n\n                line = line.substr(0, line.length - 3);\n\n                if (code >= 0xc0) {\n                    break;\n                }\n            }\n        }\n\n        if (pos + line.length < len && line.substr(-1) !== '\\n') {\n            if (line.length === lineLength && line.match(/[=][\\da-f]{2}$/i)) {\n                line = line.substr(0, line.length - 3);\n            } else if (line.length === lineLength) {\n                line = line.substr(0, line.length - 1);\n            }\n            pos += line.length;\n            line += '=\\r\\n';\n        } else {\n            pos += line.length;\n        }\n\n        result += line;\n    }\n\n    return result;\n}\n\n/**\n * Helper function to check if a number is inside provided ranges\n *\n * @param {Number} nr Number to check for\n * @param {Array} ranges An Array of allowed values\n * @returns {Boolean} True if the value was found inside allowed ranges, false otherwise\n */\nfunction checkRanges(nr, ranges) {\n    for (let i = ranges.length - 1; i >= 0; i--) {\n        if (!ranges[i].length) {\n            continue;\n        }\n        if (ranges[i].length === 1 && nr === ranges[i][0]) {\n            return true;\n        }\n        if (ranges[i].length === 2 && nr >= ranges[i][0] && nr <= ranges[i][1]) {\n            return true;\n        }\n    }\n    return false;\n}\n\n/**\n * Creates a transform stream for encoding data to Quoted-Printable encoding\n *\n * @constructor\n * @param {Object} options Stream options\n * @param {Number} [options.lineLength=76] Maximum length for lines, set to false to disable wrapping\n */\nclass Encoder extends Transform {\n    constructor(options) {\n        super();\n\n        // init Transform\n        this.options = options || {};\n\n        if (this.options.lineLength !== false) {\n            this.options.lineLength = this.options.lineLength || 76;\n        }\n\n        this._curLine = '';\n\n        this.inputBytes = 0;\n        this.outputBytes = 0;\n    }\n\n    _transform(chunk, encoding, done) {\n        let qp;\n\n        if (encoding !== 'buffer') {\n            chunk = Buffer.from(chunk, encoding);\n        }\n\n        if (!chunk || !chunk.length) {\n            return done();\n        }\n\n        this.inputBytes += chunk.length;\n\n        if (this.options.lineLength) {\n            qp = this._curLine + encode(chunk);\n            qp = wrap(qp, this.options.lineLength);\n            qp = qp.replace(/(^|\\n)([^\\n]*)$/, (match, lineBreak, lastLine) => {\n                this._curLine = lastLine;\n                return lineBreak;\n            });\n\n            if (qp) {\n                this.outputBytes += qp.length;\n                this.push(qp);\n            }\n        } else {\n            qp = encode(chunk);\n            this.outputBytes += qp.length;\n            this.push(qp, 'ascii');\n        }\n\n        done();\n    }\n\n    _flush(done) {\n        if (this._curLine) {\n            this.outputBytes += this._curLine.length;\n            this.push(this._curLine, 'ascii');\n        }\n        done();\n    }\n}\n\n// expose to the world\nmodule.exports = {\n    encode,\n    wrap,\n    Encoder\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}