{"ast":null,"code":"'use strict';\n\nconst Transform = require('stream').Transform;\n\n/**\n * MessageParser instance is a transform stream that separates message headers\n * from the rest of the body. Headers are emitted with the 'headers' event. Message\n * body is passed on as the resulting stream.\n */\nclass MessageParser extends Transform {\n  constructor(options) {\n    super(options);\n    this.lastBytes = Buffer.alloc(4);\n    this.headersParsed = false;\n    this.headerBytes = 0;\n    this.headerChunks = [];\n    this.rawHeaders = false;\n    this.bodySize = 0;\n  }\n\n  /**\n   * Keeps count of the last 4 bytes in order to detect line breaks on chunk boundaries\n   *\n   * @param {Buffer} data Next data chunk from the stream\n   */\n  updateLastBytes(data) {\n    let lblen = this.lastBytes.length;\n    let nblen = Math.min(data.length, lblen);\n\n    // shift existing bytes\n    for (let i = 0, len = lblen - nblen; i < len; i++) {\n      this.lastBytes[i] = this.lastBytes[i + nblen];\n    }\n\n    // add new bytes\n    for (let i = 1; i <= nblen; i++) {\n      this.lastBytes[lblen - i] = data[data.length - i];\n    }\n  }\n\n  /**\n   * Finds and removes message headers from the remaining body. We want to keep\n   * headers separated until final delivery to be able to modify these\n   *\n   * @param {Buffer} data Next chunk of data\n   * @return {Boolean} Returns true if headers are already found or false otherwise\n   */\n  checkHeaders(data) {\n    if (this.headersParsed) {\n      return true;\n    }\n    let lblen = this.lastBytes.length;\n    let headerPos = 0;\n    this.curLinePos = 0;\n    for (let i = 0, len = this.lastBytes.length + data.length; i < len; i++) {\n      let chr;\n      if (i < lblen) {\n        chr = this.lastBytes[i];\n      } else {\n        chr = data[i - lblen];\n      }\n      if (chr === 0x0a && i) {\n        let pr1 = i - 1 < lblen ? this.lastBytes[i - 1] : data[i - 1 - lblen];\n        let pr2 = i > 1 ? i - 2 < lblen ? this.lastBytes[i - 2] : data[i - 2 - lblen] : false;\n        if (pr1 === 0x0a) {\n          this.headersParsed = true;\n          headerPos = i - lblen + 1;\n          this.headerBytes += headerPos;\n          break;\n        } else if (pr1 === 0x0d && pr2 === 0x0a) {\n          this.headersParsed = true;\n          headerPos = i - lblen + 1;\n          this.headerBytes += headerPos;\n          break;\n        }\n      }\n    }\n    if (this.headersParsed) {\n      this.headerChunks.push(data.slice(0, headerPos));\n      this.rawHeaders = Buffer.concat(this.headerChunks, this.headerBytes);\n      this.headerChunks = null;\n      this.emit('headers', this.parseHeaders());\n      if (data.length - 1 > headerPos) {\n        let chunk = data.slice(headerPos);\n        this.bodySize += chunk.length;\n        // this would be the first chunk of data sent downstream\n        setImmediate(() => this.push(chunk));\n      }\n      return false;\n    } else {\n      this.headerBytes += data.length;\n      this.headerChunks.push(data);\n    }\n\n    // store last 4 bytes to catch header break\n    this.updateLastBytes(data);\n    return false;\n  }\n  _transform(chunk, encoding, callback) {\n    if (!chunk || !chunk.length) {\n      return callback();\n    }\n    if (typeof chunk === 'string') {\n      chunk = Buffer.from(chunk, encoding);\n    }\n    let headersFound;\n    try {\n      headersFound = this.checkHeaders(chunk);\n    } catch (E) {\n      return callback(E);\n    }\n    if (headersFound) {\n      this.bodySize += chunk.length;\n      this.push(chunk);\n    }\n    setImmediate(callback);\n  }\n  _flush(callback) {\n    if (this.headerChunks) {\n      let chunk = Buffer.concat(this.headerChunks, this.headerBytes);\n      this.bodySize += chunk.length;\n      this.push(chunk);\n      this.headerChunks = null;\n    }\n    callback();\n  }\n  parseHeaders() {\n    let lines = (this.rawHeaders || '').toString().split(/\\r?\\n/);\n    for (let i = lines.length - 1; i > 0; i--) {\n      if (/^\\s/.test(lines[i])) {\n        lines[i - 1] += '\\n' + lines[i];\n        lines.splice(i, 1);\n      }\n    }\n    return lines.filter(line => line.trim()).map(line => ({\n      key: line.substr(0, line.indexOf(':')).trim().toLowerCase(),\n      line\n    }));\n  }\n}\nmodule.exports = MessageParser;","map":{"version":3,"names":["Transform","require","MessageParser","constructor","options","lastBytes","Buffer","alloc","headersParsed","headerBytes","headerChunks","rawHeaders","bodySize","updateLastBytes","data","lblen","length","nblen","Math","min","i","len","checkHeaders","headerPos","curLinePos","chr","pr1","pr2","push","slice","concat","emit","parseHeaders","chunk","setImmediate","_transform","encoding","callback","from","headersFound","E","_flush","lines","toString","split","test","splice","filter","line","trim","map","key","substr","indexOf","toLowerCase","module","exports"],"sources":["C:/Users/deiby/Desktop/cloneWebCursos/paginacursos/node_modules/nodemailer/lib/dkim/message-parser.js"],"sourcesContent":["'use strict';\n\nconst Transform = require('stream').Transform;\n\n/**\n * MessageParser instance is a transform stream that separates message headers\n * from the rest of the body. Headers are emitted with the 'headers' event. Message\n * body is passed on as the resulting stream.\n */\nclass MessageParser extends Transform {\n    constructor(options) {\n        super(options);\n        this.lastBytes = Buffer.alloc(4);\n        this.headersParsed = false;\n        this.headerBytes = 0;\n        this.headerChunks = [];\n        this.rawHeaders = false;\n        this.bodySize = 0;\n    }\n\n    /**\n     * Keeps count of the last 4 bytes in order to detect line breaks on chunk boundaries\n     *\n     * @param {Buffer} data Next data chunk from the stream\n     */\n    updateLastBytes(data) {\n        let lblen = this.lastBytes.length;\n        let nblen = Math.min(data.length, lblen);\n\n        // shift existing bytes\n        for (let i = 0, len = lblen - nblen; i < len; i++) {\n            this.lastBytes[i] = this.lastBytes[i + nblen];\n        }\n\n        // add new bytes\n        for (let i = 1; i <= nblen; i++) {\n            this.lastBytes[lblen - i] = data[data.length - i];\n        }\n    }\n\n    /**\n     * Finds and removes message headers from the remaining body. We want to keep\n     * headers separated until final delivery to be able to modify these\n     *\n     * @param {Buffer} data Next chunk of data\n     * @return {Boolean} Returns true if headers are already found or false otherwise\n     */\n    checkHeaders(data) {\n        if (this.headersParsed) {\n            return true;\n        }\n\n        let lblen = this.lastBytes.length;\n        let headerPos = 0;\n        this.curLinePos = 0;\n        for (let i = 0, len = this.lastBytes.length + data.length; i < len; i++) {\n            let chr;\n            if (i < lblen) {\n                chr = this.lastBytes[i];\n            } else {\n                chr = data[i - lblen];\n            }\n            if (chr === 0x0a && i) {\n                let pr1 = i - 1 < lblen ? this.lastBytes[i - 1] : data[i - 1 - lblen];\n                let pr2 = i > 1 ? (i - 2 < lblen ? this.lastBytes[i - 2] : data[i - 2 - lblen]) : false;\n                if (pr1 === 0x0a) {\n                    this.headersParsed = true;\n                    headerPos = i - lblen + 1;\n                    this.headerBytes += headerPos;\n                    break;\n                } else if (pr1 === 0x0d && pr2 === 0x0a) {\n                    this.headersParsed = true;\n                    headerPos = i - lblen + 1;\n                    this.headerBytes += headerPos;\n                    break;\n                }\n            }\n        }\n\n        if (this.headersParsed) {\n            this.headerChunks.push(data.slice(0, headerPos));\n            this.rawHeaders = Buffer.concat(this.headerChunks, this.headerBytes);\n            this.headerChunks = null;\n            this.emit('headers', this.parseHeaders());\n            if (data.length - 1 > headerPos) {\n                let chunk = data.slice(headerPos);\n                this.bodySize += chunk.length;\n                // this would be the first chunk of data sent downstream\n                setImmediate(() => this.push(chunk));\n            }\n            return false;\n        } else {\n            this.headerBytes += data.length;\n            this.headerChunks.push(data);\n        }\n\n        // store last 4 bytes to catch header break\n        this.updateLastBytes(data);\n\n        return false;\n    }\n\n    _transform(chunk, encoding, callback) {\n        if (!chunk || !chunk.length) {\n            return callback();\n        }\n\n        if (typeof chunk === 'string') {\n            chunk = Buffer.from(chunk, encoding);\n        }\n\n        let headersFound;\n\n        try {\n            headersFound = this.checkHeaders(chunk);\n        } catch (E) {\n            return callback(E);\n        }\n\n        if (headersFound) {\n            this.bodySize += chunk.length;\n            this.push(chunk);\n        }\n\n        setImmediate(callback);\n    }\n\n    _flush(callback) {\n        if (this.headerChunks) {\n            let chunk = Buffer.concat(this.headerChunks, this.headerBytes);\n            this.bodySize += chunk.length;\n            this.push(chunk);\n            this.headerChunks = null;\n        }\n        callback();\n    }\n\n    parseHeaders() {\n        let lines = (this.rawHeaders || '').toString().split(/\\r?\\n/);\n        for (let i = lines.length - 1; i > 0; i--) {\n            if (/^\\s/.test(lines[i])) {\n                lines[i - 1] += '\\n' + lines[i];\n                lines.splice(i, 1);\n            }\n        }\n        return lines\n            .filter(line => line.trim())\n            .map(line => ({\n                key: line.substr(0, line.indexOf(':')).trim().toLowerCase(),\n                line\n            }));\n    }\n}\n\nmodule.exports = MessageParser;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}