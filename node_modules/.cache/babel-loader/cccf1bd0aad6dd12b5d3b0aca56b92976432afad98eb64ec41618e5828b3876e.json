{"ast":null,"code":"'use strict';\n\n// undocumented cb() API, needed for core, not for public API\nfunction destroy(err, cb) {\n  var _this = this;\n  var readableDestroyed = this._readableState && this._readableState.destroyed;\n  var writableDestroyed = this._writableState && this._writableState.destroyed;\n  if (readableDestroyed || writableDestroyed) {\n    if (cb) {\n      cb(err);\n    } else if (err) {\n      if (!this._writableState) {\n        process.nextTick(emitErrorNT, this, err);\n      } else if (!this._writableState.errorEmitted) {\n        this._writableState.errorEmitted = true;\n        process.nextTick(emitErrorNT, this, err);\n      }\n    }\n    return this;\n  } // we set destroyed to true before firing error callbacks in order\n  // to make it re-entrance safe in case destroy() is called within callbacks\n\n  if (this._readableState) {\n    this._readableState.destroyed = true;\n  } // if this is a duplex stream mark the writable part as destroyed as well\n\n  if (this._writableState) {\n    this._writableState.destroyed = true;\n  }\n  this._destroy(err || null, function (err) {\n    if (!cb && err) {\n      if (!_this._writableState) {\n        process.nextTick(emitErrorAndCloseNT, _this, err);\n      } else if (!_this._writableState.errorEmitted) {\n        _this._writableState.errorEmitted = true;\n        process.nextTick(emitErrorAndCloseNT, _this, err);\n      } else {\n        process.nextTick(emitCloseNT, _this);\n      }\n    } else if (cb) {\n      process.nextTick(emitCloseNT, _this);\n      cb(err);\n    } else {\n      process.nextTick(emitCloseNT, _this);\n    }\n  });\n  return this;\n}\nfunction emitErrorAndCloseNT(self, err) {\n  emitErrorNT(self, err);\n  emitCloseNT(self);\n}\nfunction emitCloseNT(self) {\n  if (self._writableState && !self._writableState.emitClose) return;\n  if (self._readableState && !self._readableState.emitClose) return;\n  self.emit('close');\n}\nfunction undestroy() {\n  if (this._readableState) {\n    this._readableState.destroyed = false;\n    this._readableState.reading = false;\n    this._readableState.ended = false;\n    this._readableState.endEmitted = false;\n  }\n  if (this._writableState) {\n    this._writableState.destroyed = false;\n    this._writableState.ended = false;\n    this._writableState.ending = false;\n    this._writableState.finalCalled = false;\n    this._writableState.prefinished = false;\n    this._writableState.finished = false;\n    this._writableState.errorEmitted = false;\n  }\n}\nfunction emitErrorNT(self, err) {\n  self.emit('error', err);\n}\nfunction errorOrDestroy(stream, err) {\n  // We have tests that rely on errors being emitted\n  // in the same tick, so changing this is semver major.\n  // For now when you opt-in to autoDestroy we allow\n  // the error to be emitted nextTick. In a future\n  // semver major update we should change the default to this.\n  var rState = stream._readableState;\n  var wState = stream._writableState;\n  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);\n}\nmodule.exports = {\n  destroy: destroy,\n  undestroy: undestroy,\n  errorOrDestroy: errorOrDestroy\n};","map":{"version":3,"names":["destroy","err","cb","_this","readableDestroyed","_readableState","destroyed","writableDestroyed","_writableState","process","nextTick","emitErrorNT","errorEmitted","_destroy","emitErrorAndCloseNT","emitCloseNT","self","emitClose","emit","undestroy","reading","ended","endEmitted","ending","finalCalled","prefinished","finished","errorOrDestroy","stream","rState","wState","autoDestroy","module","exports"],"sources":["C:/Users/deiby/Desktop/cloneWebCursos/paginacursos/node_modules/readable-stream/lib/internal/streams/destroy.js"],"sourcesContent":["'use strict'; // undocumented cb() API, needed for core, not for public API\r\n\r\nfunction destroy(err, cb) {\r\n  var _this = this;\r\n\r\n  var readableDestroyed = this._readableState && this._readableState.destroyed;\r\n  var writableDestroyed = this._writableState && this._writableState.destroyed;\r\n\r\n  if (readableDestroyed || writableDestroyed) {\r\n    if (cb) {\r\n      cb(err);\r\n    } else if (err) {\r\n      if (!this._writableState) {\r\n        process.nextTick(emitErrorNT, this, err);\r\n      } else if (!this._writableState.errorEmitted) {\r\n        this._writableState.errorEmitted = true;\r\n        process.nextTick(emitErrorNT, this, err);\r\n      }\r\n    }\r\n\r\n    return this;\r\n  } // we set destroyed to true before firing error callbacks in order\r\n  // to make it re-entrance safe in case destroy() is called within callbacks\r\n\r\n\r\n  if (this._readableState) {\r\n    this._readableState.destroyed = true;\r\n  } // if this is a duplex stream mark the writable part as destroyed as well\r\n\r\n\r\n  if (this._writableState) {\r\n    this._writableState.destroyed = true;\r\n  }\r\n\r\n  this._destroy(err || null, function (err) {\r\n    if (!cb && err) {\r\n      if (!_this._writableState) {\r\n        process.nextTick(emitErrorAndCloseNT, _this, err);\r\n      } else if (!_this._writableState.errorEmitted) {\r\n        _this._writableState.errorEmitted = true;\r\n        process.nextTick(emitErrorAndCloseNT, _this, err);\r\n      } else {\r\n        process.nextTick(emitCloseNT, _this);\r\n      }\r\n    } else if (cb) {\r\n      process.nextTick(emitCloseNT, _this);\r\n      cb(err);\r\n    } else {\r\n      process.nextTick(emitCloseNT, _this);\r\n    }\r\n  });\r\n\r\n  return this;\r\n}\r\n\r\nfunction emitErrorAndCloseNT(self, err) {\r\n  emitErrorNT(self, err);\r\n  emitCloseNT(self);\r\n}\r\n\r\nfunction emitCloseNT(self) {\r\n  if (self._writableState && !self._writableState.emitClose) return;\r\n  if (self._readableState && !self._readableState.emitClose) return;\r\n  self.emit('close');\r\n}\r\n\r\nfunction undestroy() {\r\n  if (this._readableState) {\r\n    this._readableState.destroyed = false;\r\n    this._readableState.reading = false;\r\n    this._readableState.ended = false;\r\n    this._readableState.endEmitted = false;\r\n  }\r\n\r\n  if (this._writableState) {\r\n    this._writableState.destroyed = false;\r\n    this._writableState.ended = false;\r\n    this._writableState.ending = false;\r\n    this._writableState.finalCalled = false;\r\n    this._writableState.prefinished = false;\r\n    this._writableState.finished = false;\r\n    this._writableState.errorEmitted = false;\r\n  }\r\n}\r\n\r\nfunction emitErrorNT(self, err) {\r\n  self.emit('error', err);\r\n}\r\n\r\nfunction errorOrDestroy(stream, err) {\r\n  // We have tests that rely on errors being emitted\r\n  // in the same tick, so changing this is semver major.\r\n  // For now when you opt-in to autoDestroy we allow\r\n  // the error to be emitted nextTick. In a future\r\n  // semver major update we should change the default to this.\r\n  var rState = stream._readableState;\r\n  var wState = stream._writableState;\r\n  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);\r\n}\r\n\r\nmodule.exports = {\r\n  destroy: destroy,\r\n  undestroy: undestroy,\r\n  errorOrDestroy: errorOrDestroy\r\n};"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}